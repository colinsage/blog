{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/fexo/source/css/styles.css","path":"css/styles.css","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.eot","path":"fonts/PoiretOne-Regular.eot","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.ttf","path":"fonts/PoiretOne-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.woff","path":"fonts/PoiretOne-Regular.woff","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.eot","path":"fonts/calligraffitti-regular-webfont.eot","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff","path":"fonts/calligraffitti-regular-webfont.woff","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff2","path":"fonts/calligraffitti-regular-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.eot","path":"fonts/fontello.eot","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.svg","path":"fonts/fontello.svg","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.ttf","path":"fonts/fontello.ttf","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.woff","path":"fonts/fontello.woff","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.woff2","path":"fonts/fontello.woff2","modified":0,"renderable":1},{"_id":"themes/fexo/source/js/app.js","path":"js/app.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/fexo/source/js/bundle.js","path":"js/bundle.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/js/fastclick.js","path":"js/fastclick.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/js/scroll-spy.js","path":"js/scroll-spy.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/js/util.js","path":"js/util.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/js/zenscroll.js","path":"js/zenscroll.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/css/styles.css.map","path":"css/styles.css.map","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.ttf","path":"fonts/calligraffitti-regular-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.svg","path":"fonts/PoiretOne-Regular.svg","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.svg","path":"fonts/calligraffitti-regular-webfont.svg","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.eot","path":"fonts/Lobster-Regular.eot","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.woff","path":"fonts/Lobster-Regular.woff","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.ttf","path":"fonts/Lobster-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.svg","path":"fonts/Lobster-Regular.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/2017-10-18-influx-stress.md","hash":"350b5da23895e1b57edd052ac47adc980e0bab2a","modified":1519722310567},{"_id":"source/_posts/2017-10-18-misc.md","hash":"7b50a0bd83927fea991e958d4fe305d13a593252","modified":1519722310568},{"_id":"source/_posts/2017-10-19-influx-read.md","hash":"ef61981305c5d68eedb680b84d794f0a8110399e","modified":1519722310568},{"_id":"source/_posts/2017-10-19-influx-write.md","hash":"51c55857c0c55f0e292485c7b958e166972495d5","modified":1519722310570},{"_id":"source/_posts/2017-10-27-misc.md","hash":"382bd97278175e4e94d51a6140927092b696cb7a","modified":1519722310572},{"_id":"source/_posts/2017-11-01-influxdb-cluster.md","hash":"62998076575c8feb961c4606b118b829a8ff8d06","modified":1519722310572},{"_id":"source/_posts/2017-11-13-misc.md","hash":"2b0a915724b82c2619536bf78bc4812b139cfde9","modified":1519722310573},{"_id":"source/_posts/2017-11-17-tsdb-in-my-eye.md","hash":"f2ebdda0bea53fee9b50d4c6ffaed61f4eb0db6f","modified":1519722310573},{"_id":"source/_posts/2017-11-27-raft.md","hash":"bac109b192afeacd4083bfaf9b8df7e4171adb4c","modified":1519722310573},{"_id":"source/_posts/2017-12-04-influx-http-service.md","hash":"52c801ef2ca6dde15981a8d6dee6bd77b4315283","modified":1519722310573},{"_id":"source/_posts/2017-10-19-influx-write/mip-20171019150351540.png","hash":"e404354721e95bf53c7a36a165b9fb18277afc93","modified":1519722310572},{"_id":"source/_posts/2017-10-19-influx-read/mip-2017101919283058.png","hash":"5b0695dca7e2f82c7e2a76ed1a4a1f640a1ec7a2","modified":1519722310569},{"_id":"themes/fexo/.csscomb.json","hash":"0bff596879c2556634b9a92abe5b1606dc77fd1c","modified":1519726591354},{"_id":"themes/fexo/.gitignore","hash":"32223fbe296f8e3026c689bad8f3dea9d0fcbb43","modified":1519726591389},{"_id":"themes/fexo/LICENSE","hash":"db4cb5aef6072a96721b5428fdd999647c049d55","modified":1519726591337},{"_id":"themes/fexo/README.md","hash":"35cd346c229e17ed83609ee94b5d6493c4ab9982","modified":1519726591388},{"_id":"themes/fexo/_config.yml","hash":"db46d61222498f82ee0f4a7ae41cef46e4eb6bdc","modified":1519727280220},{"_id":"themes/fexo/gulpfile.js","hash":"5995b9c4e8e18d1670ad30b2881d49fa17e56415","modified":1519726591390},{"_id":"themes/fexo/package.json","hash":"38850a4aa4a01c697bdf2bed87709fe0c8c3fe69","modified":1519726591390},{"_id":"themes/fexo/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1519726591395},{"_id":"themes/fexo/.git/config","hash":"78a9f656fdfea85aaa63de99ef0857e7149d11d2","modified":1519726591391},{"_id":"themes/fexo/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1519726591400},{"_id":"themes/fexo/.git/index","hash":"f4f6d5ec502a156437464be8c0224c0a139409c9","modified":1519727042986},{"_id":"themes/fexo/.git/packed-refs","hash":"e60e09c9e808d873c989a4576d804f0fe946859c","modified":1519726591408},{"_id":"themes/fexo/languages/default.yml","hash":"1a6762d52295b0f7586f40c35e713c0fd33c2a2b","modified":1519726591387},{"_id":"themes/fexo/languages/en.yml","hash":"b58364c7dfac61eddd64510f74ca7516da48f0cf","modified":1519726591387},{"_id":"themes/fexo/languages/no.yml","hash":"bf11017d77f64fbafb9c99ac219d076b20d53afc","modified":1519726591388},{"_id":"themes/fexo/languages/zh-CN.yml","hash":"1a6762d52295b0f7586f40c35e713c0fd33c2a2b","modified":1519726591388},{"_id":"themes/fexo/languages/zh-TW.yml","hash":"6141b4c7a094c74bd9df7c08908d92b561c1a0c0","modified":1519726591387},{"_id":"themes/fexo/layout/about.ejs","hash":"f1f06842f3fac2c7dd74811722431c5720e6cf8d","modified":1519726591340},{"_id":"themes/fexo/layout/archive.ejs","hash":"9c22251c328e937c444a9f5d4b324f97a78d324f","modified":1519726591339},{"_id":"themes/fexo/layout/category.ejs","hash":"e8c8209f74ac0c96c29dbdff38d0f43664417342","modified":1519726591338},{"_id":"themes/fexo/layout/index.ejs","hash":"9d33cd03e7a8adf8bbc124c248def36c15e681d0","modified":1519726591338},{"_id":"themes/fexo/layout/layout.ejs","hash":"ae485be0f6c0c431245e0cac21dc109c9d0125e8","modified":1519726591340},{"_id":"themes/fexo/layout/link.ejs","hash":"0144bdb1bc5f19763535b79b3302bf85bc0afbff","modified":1519726591338},{"_id":"themes/fexo/layout/post.ejs","hash":"8cf15be489f8f3c11ac0215c16cbce36c854555f","modified":1519726591338},{"_id":"themes/fexo/layout/project.ejs","hash":"ea63f5ffda0d260b5dc2c2e852caddd082e37efa","modified":1519726591340},{"_id":"themes/fexo/layout/search.ejs","hash":"8c6fc59bed1facf14dd6a48bdf8dd44452583f4d","modified":1519726591339},{"_id":"themes/fexo/layout/tag.ejs","hash":"ea8f39f11e6f8750edbf4130abf26168a403b1b4","modified":1519726591339},{"_id":"themes/fexo/package-lock.json","hash":"96cbc6874ae373b7ebd91a8b2a5166e7502514fa","modified":1519726591389},{"_id":"themes/fexo/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1519726591402},{"_id":"themes/fexo/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1519726591401},{"_id":"themes/fexo/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1519726591403},{"_id":"themes/fexo/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1519726591404},{"_id":"themes/fexo/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1519726591402},{"_id":"themes/fexo/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1519726591404},{"_id":"themes/fexo/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1519726591402},{"_id":"themes/fexo/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1519726591403},{"_id":"themes/fexo/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1519726591403},{"_id":"themes/fexo/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1519726591405},{"_id":"themes/fexo/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1519726591396},{"_id":"themes/fexo/.git/logs/HEAD","hash":"8db114670998832ee5b57a27065b6d8916f6057c","modified":1519726591397},{"_id":"themes/fexo/layout/_partial/article.ejs","hash":"745f11c21dcf5d01f4aad3818777fc62e45d2f84","modified":1519726591354},{"_id":"themes/fexo/layout/_partial/baidu-analytics.ejs","hash":"c19e4abec19c23840fff7f8a51f4aefbb2b7e8ca","modified":1519726591352},{"_id":"themes/fexo/layout/_partial/baidu-push.ejs","hash":"6950255d74efac8811d5b05d0d7a263c3c96486d","modified":1519726591353},{"_id":"themes/fexo/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1519726591341},{"_id":"themes/fexo/layout/_partial/head.ejs","hash":"794916e761ea82fb606a2173af68e9bf524f6efb","modified":1519726591352},{"_id":"themes/fexo/layout/_partial/home.ejs","hash":"225b8a001c7aace46f2b39676e968e7cba9a4277","modified":1519726591352},{"_id":"themes/fexo/layout/_partial/load-script.ejs","hash":"4675c917548817118f4a3c5d84acc98d6c61a1d8","modified":1519726591353},{"_id":"themes/fexo/layout/_partial/style.ejs","hash":"d1e80d7cf8b22929f5c6d8590eac38b069ea055d","modified":1519726591354},{"_id":"themes/fexo/source/css/styles.css","hash":"edda7b8f56586203f06fb0fb1cce0f6707a7f234","modified":1519726591356},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.eot","hash":"2a4ef0d00fb77d16e37c3da429698b029e7d2d2f","modified":1519726591360},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.ttf","hash":"2b186ce205301f7f3abd441f0372b72adcd2aee3","modified":1519726591363},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.woff","hash":"1cebcedde2c52261591bc322b176638798336a24","modified":1519726591365},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.eot","hash":"4c7bcece73621f648fa71d58fa13c28670fed8ca","modified":1519726591361},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff","hash":"1364845a3815740c572e29c83fd8d54f1c1ef5de","modified":1519726591360},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff2","hash":"ba50c427166090361b0dab4c72136c7b451e86d4","modified":1519726591364},{"_id":"themes/fexo/source/fonts/fontello.eot","hash":"7732065eeaec4614e9548955d9bd30ccd7b149c1","modified":1519726591363},{"_id":"themes/fexo/source/fonts/fontello.svg","hash":"33a984f4482a5ba5e7bc67d82e8db63cda4e3ae1","modified":1519726591366},{"_id":"themes/fexo/source/fonts/fontello.ttf","hash":"e255d37ca14348e9a8532667a757ab552e58caff","modified":1519726591361},{"_id":"themes/fexo/source/fonts/fontello.woff","hash":"45737fea847f3942ef405f00ea4df940fbb6bbd9","modified":1519726591362},{"_id":"themes/fexo/source/fonts/fontello.woff2","hash":"1dfbc23328582f7cd9bcbe538224f6c762023e43","modified":1519726591367},{"_id":"themes/fexo/source/js/app.js","hash":"a6d6e7fba3d69d0dec2c4d18debe0dc4cc7ab319","modified":1519726591359},{"_id":"themes/fexo/source/images/avatar.jpg","hash":"06b315b1cde634d2313044a83c40b1ac10961134","modified":1519726591357},{"_id":"themes/fexo/source/js/bundle.js","hash":"fe2b6d4fbc32c78cd9868fb3b75ad71cf5250f24","modified":1519726591358},{"_id":"themes/fexo/source/js/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1519726591359},{"_id":"themes/fexo/source/js/scroll-spy.js","hash":"81b81362fcd63592045a673b54ce1edb7a6e3028","modified":1519726591359},{"_id":"themes/fexo/source/js/util.js","hash":"8136da2bec1faf5fe3e14fa436f501292fca8c07","modified":1519726591357},{"_id":"themes/fexo/source/js/zenscroll.js","hash":"bea2a3571555fdae64e8fc56f161f9a4f427b335","modified":1519726591358},{"_id":"themes/fexo/source/sass/_animate.scss","hash":"8de97c948cb4b9c9b7a87c0f7332ed534c378e26","modified":1519726591380},{"_id":"themes/fexo/source/sass/_base.scss","hash":"83f01dbe82e47ce781c6e7eb8a793d95d97e168b","modified":1519726591386},{"_id":"themes/fexo/source/sass/_common.scss","hash":"b1fc97d6d24a92a9a7a9d39be4fe844f5c0f6d44","modified":1519726591379},{"_id":"themes/fexo/source/sass/_fontello.scss","hash":"f2d6b86bb63459884cf63e8c045fd10c827396eb","modified":1519726591386},{"_id":"themes/fexo/source/sass/_fonts.scss","hash":"10e188d379782ae2ee10427544919557036d0137","modified":1519726591368},{"_id":"themes/fexo/source/sass/_highlight-js.scss","hash":"38a5c4d9f3a2943aff9bde1d624d710587e3bc05","modified":1519726591379},{"_id":"themes/fexo/source/sass/_normalize.scss","hash":"e58275a588bb631a37a2988145eea231ed23176b","modified":1519726591385},{"_id":"themes/fexo/source/sass/_styles.scss","hash":"86ebe05d6a2931dd6fceef1e50c31ca996dc20be","modified":1519726591368},{"_id":"themes/fexo/source/sass/_type.scss","hash":"cc7a25654593030f5214d5adf85f12a954c373c5","modified":1519726591385},{"_id":"themes/fexo/source/sass/_variable.scss","hash":"7b05581ef035a88bd1191914ff992103c7812bdf","modified":1519726591380},{"_id":"themes/fexo/source/css/styles.css.map","hash":"dd689c0ab08f3e7923ede7fab9a193c63f253d90","modified":1519726591356},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.ttf","hash":"4688935c427ae40dcbf16523bc11d9fc10e359b5","modified":1519726591362},{"_id":"themes/fexo/source/sass/pages/_tag.scss","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1519726591382},{"_id":"themes/fexo/.git/refs/heads/master","hash":"834e14ffb65857cd32c5784ce5214e923e1583cc","modified":1519726591406},{"_id":"themes/fexo/layout/_partial/component/back-top.ejs","hash":"47f2b8306b901f0fffc6aa0cfa40db697a0c5aff","modified":1519726591351},{"_id":"themes/fexo/layout/_partial/component/category-box.ejs","hash":"f18e08e5c8718d5cd6672fc01e25ba457db0a385","modified":1519726591346},{"_id":"themes/fexo/layout/_partial/component/category.ejs","hash":"2429158ff177b8876de765498b54d0c91b3fc551","modified":1519726591343},{"_id":"themes/fexo/layout/_partial/component/changyan.ejs","hash":"a5f39aa1ee2f213324889ba05b5f99eaabf13fc9","modified":1519726591341},{"_id":"themes/fexo/layout/_partial/component/comments.ejs","hash":"8d719cdeeda9d5ab5fbfb5f302fc6edd5bb684b8","modified":1519726591347},{"_id":"themes/fexo/layout/_partial/component/date.ejs","hash":"163fbd874481cb9e2b6da5282701a3fbaa4e367a","modified":1519726591348},{"_id":"themes/fexo/layout/_partial/component/disqus.ejs","hash":"21de7498d235a52337335108fce7446e1a21ea1c","modified":1519726591342},{"_id":"themes/fexo/layout/_partial/component/donation.ejs","hash":"d5b7f72e008d764f5b5fb13ba6ac7adb8bc0a3e8","modified":1519726591351},{"_id":"themes/fexo/layout/_partial/component/gentie.ejs","hash":"9b78a138fb93a71b481ab25c8dea2e082e5e9d6c","modified":1519726591347},{"_id":"themes/fexo/layout/_partial/component/gitalk.ejs","hash":"37ccc1b114d6fc83c1d47fe7b931d42899f7325f","modified":1519726591341},{"_id":"themes/fexo/layout/_partial/component/gitment.ejs","hash":"cf48268f8b8b0f5a5de6c3d4cf0def9917d5f32d","modified":1519726591349},{"_id":"themes/fexo/layout/_partial/component/hypercomments.ejs","hash":"321339582edb1dd9c4e4ca13108fe494d08494fc","modified":1519726591351},{"_id":"themes/fexo/layout/_partial/component/item-category-name.ejs","hash":"8ab52c9b5d5db1d3c1d343ecb405c4e15cd144ac","modified":1519726591342},{"_id":"themes/fexo/layout/_partial/component/item-post.ejs","hash":"722e5dbde2d4683eea08f2af922358db45b253b1","modified":1519726591345},{"_id":"themes/fexo/layout/_partial/component/item-tag.ejs","hash":"1b4c4e090c33ccfd44b531a5de9af16eec266512","modified":1519726591344},{"_id":"themes/fexo/layout/_partial/component/item-year.ejs","hash":"906a6aea44a30e83c4c4e449294c7e4d831c188e","modified":1519726591347},{"_id":"themes/fexo/layout/_partial/component/modal.ejs","hash":"8edceb2fd6c770691bd5cf4a35236c1def8410fe","modified":1519726591350},{"_id":"themes/fexo/layout/_partial/component/page-header.ejs","hash":"14bad32082d87d7eeb45c0e9079e72f0ae65dbf4","modified":1519726591349},{"_id":"themes/fexo/layout/_partial/component/pagination.ejs","hash":"ffbb548aee6e15cae924ee7f922f28b2403e8e45","modified":1519726591343},{"_id":"themes/fexo/layout/_partial/component/prev-net.ejs","hash":"d1cb2e61814bcbd25ccb1628f99b18316e029892","modified":1519726591342},{"_id":"themes/fexo/layout/_partial/component/tag-box.ejs","hash":"d648ea91ec9dc72bca80d70fbb66f7655bd0ea12","modified":1519726591346},{"_id":"themes/fexo/layout/_partial/component/tag-list.ejs","hash":"8535c40b573744ced738b051383c0feca80eb0e9","modified":1519726591344},{"_id":"themes/fexo/layout/_partial/component/title.ejs","hash":"e2fcdd904123186648513cfca4c7ad04921d2d57","modified":1519726591344},{"_id":"themes/fexo/layout/_partial/component/toc.ejs","hash":"000be428e925f5595af29eeba37ba6111f7f6511","modified":1519726591349},{"_id":"themes/fexo/layout/_partial/component/toolbox.ejs","hash":"fcfcccc5b231c4050f1a665b70f7738f9d070541","modified":1519726591348},{"_id":"themes/fexo/layout/_partial/component/uyan.ejs","hash":"afe757c6f45d24640b22d90db6f2799000c6f994","modified":1519726591350},{"_id":"themes/fexo/layout/_partial/component/valine.ejs","hash":"3cbf565937f31001c901e451677e7adbe228bfe6","modified":1519726591345},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.svg","hash":"e21109783f218cb7849b12e867e0b775ce3fadda","modified":1519726591367},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.svg","hash":"76e1e4cee6f2b5d596c635631938ee5eb6ab3e67","modified":1519726591367},{"_id":"themes/fexo/source/sass/component/_back-top.scss","hash":"1c67da7007f4b9d8c65deea3d82c0f579e65f2c2","modified":1519726591373},{"_id":"themes/fexo/source/sass/component/_category-box.scss","hash":"a807145b74d1b98270ea19ae35edd25b4c448bfa","modified":1519726591371},{"_id":"themes/fexo/source/sass/component/_comments.scss","hash":"3e9b61bc08f38f947f54e942986a19a7f95ce723","modified":1519726591376},{"_id":"themes/fexo/source/sass/component/_donation.scss","hash":"75102b0e6e4ef0a674f04fc8996c8f7ad058143d","modified":1519726591371},{"_id":"themes/fexo/source/sass/component/_hint.scss","hash":"2812b4e10313168f2e082b740c60d64a151d94c8","modified":1519726591371},{"_id":"themes/fexo/source/sass/component/_index.scss","hash":"a741a0bfb47d0acdef12cdeb968c104bb002f86d","modified":1519726591369},{"_id":"themes/fexo/source/sass/component/_item-category-name.scss","hash":"119840d160cd263b57e79e2099a81079d7eeee3d","modified":1519726591374},{"_id":"themes/fexo/source/sass/component/_item-post.scss","hash":"1fb2e9be2d2edbb538cfbce7c80d5847f88e2f05","modified":1519726591377},{"_id":"themes/fexo/source/sass/component/_item-title.scss","hash":"cdaca2858abc9428ef01103a7fbea8f095d856aa","modified":1519726591375},{"_id":"themes/fexo/source/sass/component/_item-year.scss","hash":"12c147dd4ab9587cd622083c86c2f6cf07d8e26a","modified":1519726591372},{"_id":"themes/fexo/source/sass/component/_list-post.scss","hash":"43564f6443385bf34e15672d1477d1c7560f5563","modified":1519726591377},{"_id":"themes/fexo/source/sass/component/_modal.scss","hash":"2f0ed96df388ec28445b1ce5c6a61a0a697f9a68","modified":1519726591378},{"_id":"themes/fexo/source/sass/component/_page-header.scss","hash":"893d0595ef48323dce449ef0d17308ce02b36087","modified":1519726591370},{"_id":"themes/fexo/source/sass/component/_pagination.scss","hash":"12c1880c518aee2e3ccf59661d01c308639f8a9e","modified":1519726591376},{"_id":"themes/fexo/source/sass/component/_prev-net.scss","hash":"1d282b3302e222adbc96a259f69d85afed980bcf","modified":1519726591369},{"_id":"themes/fexo/source/sass/component/_table.scss","hash":"4899fb31d1be8d5c9c397fcbcfc2ff0c5b2e7f7f","modified":1519726591373},{"_id":"themes/fexo/source/sass/component/_tag-box.scss","hash":"7601951d09a75a7c39493bfa1b1da5ac989d9cda","modified":1519726591378},{"_id":"themes/fexo/source/sass/component/_toc.scss","hash":"3b4c083cb2ba4a88ca35b6d8259ee991c83b3406","modified":1519726591372},{"_id":"themes/fexo/source/sass/component/_toolbox-mobile.scss","hash":"f15b215b9bb103ee1773a01d8badd81bb7643710","modified":1519726591377},{"_id":"themes/fexo/source/sass/component/_toolbox.scss","hash":"964a480d4e7fad100463195cde2a3f67f9765c23","modified":1519726591370},{"_id":"themes/fexo/source/sass/pages/_about.scss","hash":"7d61e627ea5376390081e0b93db426ffc6c4dee8","modified":1519726591382},{"_id":"themes/fexo/source/sass/pages/_archive.scss","hash":"fefd54282a42ebb68b711f1cfefa1f67abbde05b","modified":1519726591382},{"_id":"themes/fexo/source/sass/pages/_category.scss","hash":"713242d10c0c8687c9e2f287f1beeb38de6cdbad","modified":1519726591381},{"_id":"themes/fexo/source/sass/pages/_home.scss","hash":"b65bb069ed28fbf223c5bb7e760882f79d20fa46","modified":1519726591384},{"_id":"themes/fexo/source/sass/pages/_index.scss","hash":"d9fe73a87585abad06a7dd77b67ec7ce6c24402c","modified":1519726591381},{"_id":"themes/fexo/source/sass/pages/_link.scss","hash":"d3a249423c7ee88d1cb3a12e03f6c42a0a4d45a1","modified":1519726591384},{"_id":"themes/fexo/source/sass/pages/_post.scss","hash":"c6f694568af362f9fe1e7e2b9909e47303178116","modified":1519726591384},{"_id":"themes/fexo/source/sass/pages/_project.scss","hash":"cab0947fc9d7926a07badaa567803cc7a0968f10","modified":1519726591383},{"_id":"themes/fexo/source/sass/pages/_search.scss","hash":"fd28f01829628c9d21f9391d5067ddcd836dad13","modified":1519726591383},{"_id":"themes/fexo/.git/objects/pack/pack-07a5c30209c819fe5958d4df94aaca9b263cd242.idx","hash":"604b3fab89b89d9c6a17ee9caf74f6ec39475847","modified":1519726591395},{"_id":"themes/fexo/.git/logs/refs/heads/master","hash":"8db114670998832ee5b57a27065b6d8916f6057c","modified":1519726591399},{"_id":"themes/fexo/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1519726591407},{"_id":"themes/fexo/.git/logs/refs/remotes/origin/HEAD","hash":"8db114670998832ee5b57a27065b6d8916f6057c","modified":1519726591400},{"_id":"themes/fexo/source/fonts/Lobster-Regular.eot","hash":"4f0c85f63beb0d95610317e16f1d4acdd2962eee","modified":1519726591365},{"_id":"themes/fexo/source/fonts/Lobster-Regular.woff","hash":"298b80b1c9f694e1a055d62a5d809863c89baf50","modified":1519726591362},{"_id":"themes/fexo/source/fonts/Lobster-Regular.ttf","hash":"50a84291b7012bfdcf9ff5116d6c7aa3f257f37f","modified":1519726591366},{"_id":"themes/fexo/source/fonts/Lobster-Regular.svg","hash":"be1cab622c673942fb4d11a23c012227938b4792","modified":1519726591364},{"_id":"themes/fexo/.git/objects/pack/pack-07a5c30209c819fe5958d4df94aaca9b263cd242.pack","hash":"ae98c19ba6f0213ccb19f1c149832d2eaf67a979","modified":1519726591394}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"20171018-misc","date":"2017-10-18T09:02:09.000Z","_content":"\n## 2017.10.18\n### 1. 迁移vps\n   目前使用的linode的东京1机房的vps，经常重启维护， 每次都要手工恢复，比较麻烦。这个vps上scp命令经常不能正确执行， 也是个头疼的问题。\n刚好又发现其他机房支持$5/mon的套餐，就动了换机房的心思。\n   通过support，寻求官方技术支持。 由于时差，大概隔了一天才回复。不过有商业支持，的确是很爽的，可以少走弯路，节省时间。   \n   按照说明，通过clone的方式最便捷。 不幸的是，过去的($10/mon)1G套餐磁盘是24G, 现在那个最低套餐磁盘只有20G.\n镜像不能复制过去，那就只能手工复制搞了。复制过程中，发现东京2机房网络叫一个烂，丢包非常严重，基本的终端命令都不能输入，无奈作罢。\n   东京1虽然贵一点，但是网络好，无明显丢包，而且rt只有60ms左右，比有些国内的站点延迟还小。\n国内王者荣耀，ping经常在90ms左右，这个将来完全也作为游戏加速器。最后决定暂时不迁了， 为了这个网络每月多付5刀也是值得的。\n\n### 2. 家庭大门监控\n   昨天小区遇到盗贼，有些邻居的家被盗了。当时心里就想着，家里门口应该安装一个监控。\n这样一方面可以威慑盗窃罪，另一方面遇盗后也能比较方便的抓住坏人。刚好，老婆淘到1个旧的萤石C2S监控摄像头。\n于是，可以动手玩一玩了。  这个监控摄像头功能不少。  \n优点:\n1. 云端存储。可以保留一周内的视频\n2. 对话。可在手机上和摄像头前面的人对话。\n3. 夜间红外。光线不好的情况下，可以录黑白的视频。\n\n\n 不好的地方：\n1. 彩色模式不敏感。 光线较强时，还是黑白的。\n2. 密码问题。那个设备验证码试了很多次都是错的。最后reset才恢复。\n3. 需要外接电源。目前是接在门口弱电箱的插线板上。要是能自发电，就完美了。或者有电池，可以每周换一次。\n\n### 3. 博客笔记\n  目前笔记产品很多，主要是云产品。由于某些限制，不能使用云笔记。于是寻找本地的替代方案。\nHexo之前用过，界面美观，使用简单。主要问题是图片保存比较麻烦，尤其是屏幕截图的。我经常使用Atom编辑markdown文件。\n希望能在atom里，保存屏幕截图的图片并生成正确的路径。   \n\n找到1个插件 **Markdown-img-paste** 基本满足需求，但是保存的目录hexo不识别。\n找到源码，改了一下可以完美保存支持hexo的图片。\n[github-link](https://github.com/colinsage/markdown-img-paste/tree/support-hexo)   \n  可以checkout下来到~/.atom/packages， 然后切换到support-hexo分支。重启Atom会自动加载。\n","source":"_posts/2017-10-18-misc.md","raw":"---\ntitle: 20171018-misc\ndate: 2017-10-18 17:02:09\ntags:\n- tips\n- life\n---\n\n## 2017.10.18\n### 1. 迁移vps\n   目前使用的linode的东京1机房的vps，经常重启维护， 每次都要手工恢复，比较麻烦。这个vps上scp命令经常不能正确执行， 也是个头疼的问题。\n刚好又发现其他机房支持$5/mon的套餐，就动了换机房的心思。\n   通过support，寻求官方技术支持。 由于时差，大概隔了一天才回复。不过有商业支持，的确是很爽的，可以少走弯路，节省时间。   \n   按照说明，通过clone的方式最便捷。 不幸的是，过去的($10/mon)1G套餐磁盘是24G, 现在那个最低套餐磁盘只有20G.\n镜像不能复制过去，那就只能手工复制搞了。复制过程中，发现东京2机房网络叫一个烂，丢包非常严重，基本的终端命令都不能输入，无奈作罢。\n   东京1虽然贵一点，但是网络好，无明显丢包，而且rt只有60ms左右，比有些国内的站点延迟还小。\n国内王者荣耀，ping经常在90ms左右，这个将来完全也作为游戏加速器。最后决定暂时不迁了， 为了这个网络每月多付5刀也是值得的。\n\n### 2. 家庭大门监控\n   昨天小区遇到盗贼，有些邻居的家被盗了。当时心里就想着，家里门口应该安装一个监控。\n这样一方面可以威慑盗窃罪，另一方面遇盗后也能比较方便的抓住坏人。刚好，老婆淘到1个旧的萤石C2S监控摄像头。\n于是，可以动手玩一玩了。  这个监控摄像头功能不少。  \n优点:\n1. 云端存储。可以保留一周内的视频\n2. 对话。可在手机上和摄像头前面的人对话。\n3. 夜间红外。光线不好的情况下，可以录黑白的视频。\n\n\n 不好的地方：\n1. 彩色模式不敏感。 光线较强时，还是黑白的。\n2. 密码问题。那个设备验证码试了很多次都是错的。最后reset才恢复。\n3. 需要外接电源。目前是接在门口弱电箱的插线板上。要是能自发电，就完美了。或者有电池，可以每周换一次。\n\n### 3. 博客笔记\n  目前笔记产品很多，主要是云产品。由于某些限制，不能使用云笔记。于是寻找本地的替代方案。\nHexo之前用过，界面美观，使用简单。主要问题是图片保存比较麻烦，尤其是屏幕截图的。我经常使用Atom编辑markdown文件。\n希望能在atom里，保存屏幕截图的图片并生成正确的路径。   \n\n找到1个插件 **Markdown-img-paste** 基本满足需求，但是保存的目录hexo不识别。\n找到源码，改了一下可以完美保存支持hexo的图片。\n[github-link](https://github.com/colinsage/markdown-img-paste/tree/support-hexo)   \n  可以checkout下来到~/.atom/packages， 然后切换到support-hexo分支。重启Atom会自动加载。\n","slug":"misc","published":1,"updated":"2018-02-27T09:05:10.568Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje5g49g40000h2vljo41dxnf","content":"<h2 id=\"2017-10-18\"><a href=\"#2017-10-18\" class=\"headerlink\" title=\"2017.10.18\"></a>2017.10.18</h2><h3 id=\"1-迁移vps\"><a href=\"#1-迁移vps\" class=\"headerlink\" title=\"1. 迁移vps\"></a>1. 迁移vps</h3><p>   目前使用的linode的东京1机房的vps，经常重启维护， 每次都要手工恢复，比较麻烦。这个vps上scp命令经常不能正确执行， 也是个头疼的问题。<br>刚好又发现其他机房支持$5/mon的套餐，就动了换机房的心思。<br>   通过support，寻求官方技术支持。 由于时差，大概隔了一天才回复。不过有商业支持，的确是很爽的，可以少走弯路，节省时间。<br>   按照说明，通过clone的方式最便捷。 不幸的是，过去的($10/mon)1G套餐磁盘是24G, 现在那个最低套餐磁盘只有20G.<br>镜像不能复制过去，那就只能手工复制搞了。复制过程中，发现东京2机房网络叫一个烂，丢包非常严重，基本的终端命令都不能输入，无奈作罢。<br>   东京1虽然贵一点，但是网络好，无明显丢包，而且rt只有60ms左右，比有些国内的站点延迟还小。<br>国内王者荣耀，ping经常在90ms左右，这个将来完全也作为游戏加速器。最后决定暂时不迁了， 为了这个网络每月多付5刀也是值得的。</p>\n<h3 id=\"2-家庭大门监控\"><a href=\"#2-家庭大门监控\" class=\"headerlink\" title=\"2. 家庭大门监控\"></a>2. 家庭大门监控</h3><p>   昨天小区遇到盗贼，有些邻居的家被盗了。当时心里就想着，家里门口应该安装一个监控。<br>这样一方面可以威慑盗窃罪，另一方面遇盗后也能比较方便的抓住坏人。刚好，老婆淘到1个旧的萤石C2S监控摄像头。<br>于是，可以动手玩一玩了。  这个监控摄像头功能不少。<br>优点:</p>\n<ol>\n<li>云端存储。可以保留一周内的视频</li>\n<li>对话。可在手机上和摄像头前面的人对话。</li>\n<li>夜间红外。光线不好的情况下，可以录黑白的视频。</li>\n</ol>\n<p> 不好的地方：</p>\n<ol>\n<li>彩色模式不敏感。 光线较强时，还是黑白的。</li>\n<li>密码问题。那个设备验证码试了很多次都是错的。最后reset才恢复。</li>\n<li>需要外接电源。目前是接在门口弱电箱的插线板上。要是能自发电，就完美了。或者有电池，可以每周换一次。</li>\n</ol>\n<h3 id=\"3-博客笔记\"><a href=\"#3-博客笔记\" class=\"headerlink\" title=\"3. 博客笔记\"></a>3. 博客笔记</h3><p>  目前笔记产品很多，主要是云产品。由于某些限制，不能使用云笔记。于是寻找本地的替代方案。<br>Hexo之前用过，界面美观，使用简单。主要问题是图片保存比较麻烦，尤其是屏幕截图的。我经常使用Atom编辑markdown文件。<br>希望能在atom里，保存屏幕截图的图片并生成正确的路径。   </p>\n<p>找到1个插件 <strong>Markdown-img-paste</strong> 基本满足需求，但是保存的目录hexo不识别。<br>找到源码，改了一下可以完美保存支持hexo的图片。<br><a href=\"https://github.com/colinsage/markdown-img-paste/tree/support-hexo\" target=\"_blank\" rel=\"noopener\">github-link</a><br>  可以checkout下来到~/.atom/packages， 然后切换到support-hexo分支。重启Atom会自动加载。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"2017-10-18\"><a href=\"#2017-10-18\" class=\"headerlink\" title=\"2017.10.18\"></a>2017.10.18</h2><h3 id=\"1-迁移vps\"><a href=\"#1-迁移vps\" class=\"headerlink\" title=\"1. 迁移vps\"></a>1. 迁移vps</h3><p>   目前使用的linode的东京1机房的vps，经常重启维护， 每次都要手工恢复，比较麻烦。这个vps上scp命令经常不能正确执行， 也是个头疼的问题。<br>刚好又发现其他机房支持$5/mon的套餐，就动了换机房的心思。<br>   通过support，寻求官方技术支持。 由于时差，大概隔了一天才回复。不过有商业支持，的确是很爽的，可以少走弯路，节省时间。<br>   按照说明，通过clone的方式最便捷。 不幸的是，过去的($10/mon)1G套餐磁盘是24G, 现在那个最低套餐磁盘只有20G.<br>镜像不能复制过去，那就只能手工复制搞了。复制过程中，发现东京2机房网络叫一个烂，丢包非常严重，基本的终端命令都不能输入，无奈作罢。<br>   东京1虽然贵一点，但是网络好，无明显丢包，而且rt只有60ms左右，比有些国内的站点延迟还小。<br>国内王者荣耀，ping经常在90ms左右，这个将来完全也作为游戏加速器。最后决定暂时不迁了， 为了这个网络每月多付5刀也是值得的。</p>\n<h3 id=\"2-家庭大门监控\"><a href=\"#2-家庭大门监控\" class=\"headerlink\" title=\"2. 家庭大门监控\"></a>2. 家庭大门监控</h3><p>   昨天小区遇到盗贼，有些邻居的家被盗了。当时心里就想着，家里门口应该安装一个监控。<br>这样一方面可以威慑盗窃罪，另一方面遇盗后也能比较方便的抓住坏人。刚好，老婆淘到1个旧的萤石C2S监控摄像头。<br>于是，可以动手玩一玩了。  这个监控摄像头功能不少。<br>优点:</p>\n<ol>\n<li>云端存储。可以保留一周内的视频</li>\n<li>对话。可在手机上和摄像头前面的人对话。</li>\n<li>夜间红外。光线不好的情况下，可以录黑白的视频。</li>\n</ol>\n<p> 不好的地方：</p>\n<ol>\n<li>彩色模式不敏感。 光线较强时，还是黑白的。</li>\n<li>密码问题。那个设备验证码试了很多次都是错的。最后reset才恢复。</li>\n<li>需要外接电源。目前是接在门口弱电箱的插线板上。要是能自发电，就完美了。或者有电池，可以每周换一次。</li>\n</ol>\n<h3 id=\"3-博客笔记\"><a href=\"#3-博客笔记\" class=\"headerlink\" title=\"3. 博客笔记\"></a>3. 博客笔记</h3><p>  目前笔记产品很多，主要是云产品。由于某些限制，不能使用云笔记。于是寻找本地的替代方案。<br>Hexo之前用过，界面美观，使用简单。主要问题是图片保存比较麻烦，尤其是屏幕截图的。我经常使用Atom编辑markdown文件。<br>希望能在atom里，保存屏幕截图的图片并生成正确的路径。   </p>\n<p>找到1个插件 <strong>Markdown-img-paste</strong> 基本满足需求，但是保存的目录hexo不识别。<br>找到源码，改了一下可以完美保存支持hexo的图片。<br><a href=\"https://github.com/colinsage/markdown-img-paste/tree/support-hexo\" target=\"_blank\" rel=\"noopener\">github-link</a><br>  可以checkout下来到~/.atom/packages， 然后切换到support-hexo分支。重启Atom会自动加载。</p>\n"},{"title":"20171027-misc","date":"2017-10-27T01:54:16.000Z","_content":"\n### 注册用的密码\n大量的网站要注册密码，使用相同的密码又不安全。一个垃圾站点泄露密码后，所有的账号都不安全了。   \n\n一种思路是对不同的网站分类，不同类别使用不同的密码。 这样可以一定程度缓解问题。 还是存在一定风险。\n当同类的泄露之后，相同级别的站点密码也需要及时修改。可以在这种思路基础之上，再加一个改变。\n在同级别的站点的密码不使用相同的， 但使用相同生成规则和salt, 再加上站点的二级域名.\n```\npasswd=rule(domain, salt)\n// 例如csdn.com, 二级域名=csdn，使用的salt=2017，rule=简单拼接，那么passwd=csdn2017\n```\n\n另一种思路是使用密码管理软件。这类软件还没使用过，不好评价。可能不是所有场景都能输入密码。\n目前使用过的浏览器表单保存工具，使用体验也不是太好。\n\n### jvm垃圾回收占用cpu超过\n   有个job被反馈cpu超用，主要是gc线程在使用cpu。后来追加了参数\"-XX:SurvivorRatio=5\n-XX:ParallelGCThreads=4\"后， 问题消除。   这里最主要的是ParallelGCThreads这个参数。\n为了提高垃圾回收的性能，java在parallel回收的时候可以设置同时并行处理的线程数也就是ParallelGCThreads，\n如果你没有设置该参数，当核数小于8时，该参数jvm会默认设置成online的cpu的核数但并不包括被shutdown的cpu的核数。\n当核数大于8时，该参数按下述公式设置.\n```\nParallelGCThreads＝8+( Processor - 8 ) ( 5/8 )\n```\n   问题出在没有设置这个参数，而程序又是跑在物理机(64核)上的。这样默认开启的线程数就太多了，\n大量gc线程没事儿干，一直处于自旋锁状态，所以cpu才会超用。\n   jvm参数的设置不能一招鲜吃遍天，有时还得考虑运行的具体环境。\n","source":"_posts/2017-10-27-misc.md","raw":"---\ntitle: 20171027-misc\ndate: 2017-10-27 09:54:16\ntags:\n---\n\n### 注册用的密码\n大量的网站要注册密码，使用相同的密码又不安全。一个垃圾站点泄露密码后，所有的账号都不安全了。   \n\n一种思路是对不同的网站分类，不同类别使用不同的密码。 这样可以一定程度缓解问题。 还是存在一定风险。\n当同类的泄露之后，相同级别的站点密码也需要及时修改。可以在这种思路基础之上，再加一个改变。\n在同级别的站点的密码不使用相同的， 但使用相同生成规则和salt, 再加上站点的二级域名.\n```\npasswd=rule(domain, salt)\n// 例如csdn.com, 二级域名=csdn，使用的salt=2017，rule=简单拼接，那么passwd=csdn2017\n```\n\n另一种思路是使用密码管理软件。这类软件还没使用过，不好评价。可能不是所有场景都能输入密码。\n目前使用过的浏览器表单保存工具，使用体验也不是太好。\n\n### jvm垃圾回收占用cpu超过\n   有个job被反馈cpu超用，主要是gc线程在使用cpu。后来追加了参数\"-XX:SurvivorRatio=5\n-XX:ParallelGCThreads=4\"后， 问题消除。   这里最主要的是ParallelGCThreads这个参数。\n为了提高垃圾回收的性能，java在parallel回收的时候可以设置同时并行处理的线程数也就是ParallelGCThreads，\n如果你没有设置该参数，当核数小于8时，该参数jvm会默认设置成online的cpu的核数但并不包括被shutdown的cpu的核数。\n当核数大于8时，该参数按下述公式设置.\n```\nParallelGCThreads＝8+( Processor - 8 ) ( 5/8 )\n```\n   问题出在没有设置这个参数，而程序又是跑在物理机(64核)上的。这样默认开启的线程数就太多了，\n大量gc线程没事儿干，一直处于自旋锁状态，所以cpu才会超用。\n   jvm参数的设置不能一招鲜吃遍天，有时还得考虑运行的具体环境。\n","slug":"misc","published":1,"updated":"2018-02-27T09:05:10.572Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje5g49gd0004h2vl1h3rq0pz","content":"<h3 id=\"注册用的密码\"><a href=\"#注册用的密码\" class=\"headerlink\" title=\"注册用的密码\"></a>注册用的密码</h3><p>大量的网站要注册密码，使用相同的密码又不安全。一个垃圾站点泄露密码后，所有的账号都不安全了。   </p>\n<p>一种思路是对不同的网站分类，不同类别使用不同的密码。 这样可以一定程度缓解问题。 还是存在一定风险。<br>当同类的泄露之后，相同级别的站点密码也需要及时修改。可以在这种思路基础之上，再加一个改变。<br>在同级别的站点的密码不使用相同的， 但使用相同生成规则和salt, 再加上站点的二级域名.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">passwd=rule(domain, salt)</div><div class=\"line\">// 例如csdn.com, 二级域名=csdn，使用的salt=2017，rule=简单拼接，那么passwd=csdn2017</div></pre></td></tr></table></figure></p>\n<p>另一种思路是使用密码管理软件。这类软件还没使用过，不好评价。可能不是所有场景都能输入密码。<br>目前使用过的浏览器表单保存工具，使用体验也不是太好。</p>\n<h3 id=\"jvm垃圾回收占用cpu超过\"><a href=\"#jvm垃圾回收占用cpu超过\" class=\"headerlink\" title=\"jvm垃圾回收占用cpu超过\"></a>jvm垃圾回收占用cpu超过</h3><p>   有个job被反馈cpu超用，主要是gc线程在使用cpu。后来追加了参数”-XX:SurvivorRatio=5<br>-XX:ParallelGCThreads=4”后， 问题消除。   这里最主要的是ParallelGCThreads这个参数。<br>为了提高垃圾回收的性能，java在parallel回收的时候可以设置同时并行处理的线程数也就是ParallelGCThreads，<br>如果你没有设置该参数，当核数小于8时，该参数jvm会默认设置成online的cpu的核数但并不包括被shutdown的cpu的核数。<br>当核数大于8时，该参数按下述公式设置.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ParallelGCThreads＝8+( Processor - 8 ) ( 5/8 )</div></pre></td></tr></table></figure></p>\n<p>   问题出在没有设置这个参数，而程序又是跑在物理机(64核)上的。这样默认开启的线程数就太多了，<br>大量gc线程没事儿干，一直处于自旋锁状态，所以cpu才会超用。<br>   jvm参数的设置不能一招鲜吃遍天，有时还得考虑运行的具体环境。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"注册用的密码\"><a href=\"#注册用的密码\" class=\"headerlink\" title=\"注册用的密码\"></a>注册用的密码</h3><p>大量的网站要注册密码，使用相同的密码又不安全。一个垃圾站点泄露密码后，所有的账号都不安全了。   </p>\n<p>一种思路是对不同的网站分类，不同类别使用不同的密码。 这样可以一定程度缓解问题。 还是存在一定风险。<br>当同类的泄露之后，相同级别的站点密码也需要及时修改。可以在这种思路基础之上，再加一个改变。<br>在同级别的站点的密码不使用相同的， 但使用相同生成规则和salt, 再加上站点的二级域名.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">passwd=rule(domain, salt)</div><div class=\"line\">// 例如csdn.com, 二级域名=csdn，使用的salt=2017，rule=简单拼接，那么passwd=csdn2017</div></pre></td></tr></table></figure></p>\n<p>另一种思路是使用密码管理软件。这类软件还没使用过，不好评价。可能不是所有场景都能输入密码。<br>目前使用过的浏览器表单保存工具，使用体验也不是太好。</p>\n<h3 id=\"jvm垃圾回收占用cpu超过\"><a href=\"#jvm垃圾回收占用cpu超过\" class=\"headerlink\" title=\"jvm垃圾回收占用cpu超过\"></a>jvm垃圾回收占用cpu超过</h3><p>   有个job被反馈cpu超用，主要是gc线程在使用cpu。后来追加了参数”-XX:SurvivorRatio=5<br>-XX:ParallelGCThreads=4”后， 问题消除。   这里最主要的是ParallelGCThreads这个参数。<br>为了提高垃圾回收的性能，java在parallel回收的时候可以设置同时并行处理的线程数也就是ParallelGCThreads，<br>如果你没有设置该参数，当核数小于8时，该参数jvm会默认设置成online的cpu的核数但并不包括被shutdown的cpu的核数。<br>当核数大于8时，该参数按下述公式设置.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ParallelGCThreads＝8+( Processor - 8 ) ( 5/8 )</div></pre></td></tr></table></figure></p>\n<p>   问题出在没有设置这个参数，而程序又是跑在物理机(64核)上的。这样默认开启的线程数就太多了，<br>大量gc线程没事儿干，一直处于自旋锁状态，所以cpu才会超用。<br>   jvm参数的设置不能一招鲜吃遍天，有时还得考虑运行的具体环境。</p>\n"},{"title":"influxdb-cluster","date":"2017-11-01T04:31:38.000Z","_content":"### 结构\n1. meta node：元数据的写，读。\n2. data node：数据的写，读\n```\n┌───────┐     ┌───────┐      \n│       │     │       │      \n│ Meta1 │◀───▶│ Meta2 │      \n│       │     │       │      \n└───────┘     └───────┘      \n    ▲             ▲          \n    │             │          \n    │  ┌───────┐  │          \n    │  │       │  │          \n    └─▶│ Meta3 │◀─┘          \n       │       │             \n       └───────┘             \n\n─────────────────────────────────\n      ╲│╱    ╲│╱             \n  ┌────┘      └──────┐       \n  │                  │       \n┌───────┐          ┌───────┐   \n│       │          │       │   \n│ Data1 │◀────────▶│ Data2 │   \n│       │          │       │   \n└───────┘          └───────┘   \n```\n\n### 写过程\n数据的分布。 有两级划分，先时间段划分成shardgroup，每个里面包含一段时间内的数据。\n时间段长度有创建的rp决定。再按照数据的measurement+tags进行hash后划分，分配到每个shard。\n每个shard落在具体的datanode机器上。\n\nshardgroup里shard个数由总机器数/复制因子算出来，取整数。每个shard根据配置的复制因子再确定出所属的\ndatanode机器。  \n\n因此写入数据时，由datanode接收写请求，根据写请求参数查询meta信息（本地缓存或者meta node）。\n结合meta信息，对于每个点，先根据timestamp路由到对应的shardgroup，再根据measurement+tags\n路由到shard，最后在把数据分别发送给对应的datanode，剩下的就是单机的写入流程。\n\n前述这些shardgorup，shard在创建shardgroup时创建好的。上述关联信息都保存在metanode中。\n\n### 读过程\n   读数据也是由datanode处理的， 请求可以落到任意一台datanode上，和Cassandra很类似。\n根据读请求查询meta信息（本地缓存或者meta node），根据时间的start，end确定shardgroup，\n然后再找到shardgroup下所有的shard，再从shard关联的datanode中选择其中一个放入请求列表，\n然后并行把请求发送给实际存储数据的datanode，最后合并分布式查询结果，并返回给客户端。\n\n### 参考资料\n1. [first:google gorup](https://groups.google.com/forum/#!msg/influxdb/3jQQMXmXd6Q/cGcmFjM-f8YJ)\n2. [0.9.0]( https://www.influxdata.com/blog/clustering-tags-and-enhancements-to-come-in-0-9-0/#signup)\n","source":"_posts/2017-11-01-influxdb-cluster.md","raw":"---\ntitle: influxdb-cluster\ndate: 2017-11-01 12:31:38\ntags:\n---\n### 结构\n1. meta node：元数据的写，读。\n2. data node：数据的写，读\n```\n┌───────┐     ┌───────┐      \n│       │     │       │      \n│ Meta1 │◀───▶│ Meta2 │      \n│       │     │       │      \n└───────┘     └───────┘      \n    ▲             ▲          \n    │             │          \n    │  ┌───────┐  │          \n    │  │       │  │          \n    └─▶│ Meta3 │◀─┘          \n       │       │             \n       └───────┘             \n\n─────────────────────────────────\n      ╲│╱    ╲│╱             \n  ┌────┘      └──────┐       \n  │                  │       \n┌───────┐          ┌───────┐   \n│       │          │       │   \n│ Data1 │◀────────▶│ Data2 │   \n│       │          │       │   \n└───────┘          └───────┘   \n```\n\n### 写过程\n数据的分布。 有两级划分，先时间段划分成shardgroup，每个里面包含一段时间内的数据。\n时间段长度有创建的rp决定。再按照数据的measurement+tags进行hash后划分，分配到每个shard。\n每个shard落在具体的datanode机器上。\n\nshardgroup里shard个数由总机器数/复制因子算出来，取整数。每个shard根据配置的复制因子再确定出所属的\ndatanode机器。  \n\n因此写入数据时，由datanode接收写请求，根据写请求参数查询meta信息（本地缓存或者meta node）。\n结合meta信息，对于每个点，先根据timestamp路由到对应的shardgroup，再根据measurement+tags\n路由到shard，最后在把数据分别发送给对应的datanode，剩下的就是单机的写入流程。\n\n前述这些shardgorup，shard在创建shardgroup时创建好的。上述关联信息都保存在metanode中。\n\n### 读过程\n   读数据也是由datanode处理的， 请求可以落到任意一台datanode上，和Cassandra很类似。\n根据读请求查询meta信息（本地缓存或者meta node），根据时间的start，end确定shardgroup，\n然后再找到shardgroup下所有的shard，再从shard关联的datanode中选择其中一个放入请求列表，\n然后并行把请求发送给实际存储数据的datanode，最后合并分布式查询结果，并返回给客户端。\n\n### 参考资料\n1. [first:google gorup](https://groups.google.com/forum/#!msg/influxdb/3jQQMXmXd6Q/cGcmFjM-f8YJ)\n2. [0.9.0]( https://www.influxdata.com/blog/clustering-tags-and-enhancements-to-come-in-0-9-0/#signup)\n","slug":"influxdb-cluster","published":1,"updated":"2018-02-27T09:05:10.572Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje5g49gf0007h2vl6ztiy8yb","content":"<h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><ol>\n<li>meta node：元数据的写，读。</li>\n<li>data node：数据的写，读<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">┌───────┐     ┌───────┐      </div><div class=\"line\">│       │     │       │      </div><div class=\"line\">│ Meta1 │◀───▶│ Meta2 │      </div><div class=\"line\">│       │     │       │      </div><div class=\"line\">└───────┘     └───────┘      </div><div class=\"line\">    ▲             ▲          </div><div class=\"line\">    │             │          </div><div class=\"line\">    │  ┌───────┐  │          </div><div class=\"line\">    │  │       │  │          </div><div class=\"line\">    └─▶│ Meta3 │◀─┘          </div><div class=\"line\">       │       │             </div><div class=\"line\">       └───────┘             </div><div class=\"line\"></div><div class=\"line\">─────────────────────────────────</div><div class=\"line\">      ╲│╱    ╲│╱             </div><div class=\"line\">  ┌────┘      └──────┐       </div><div class=\"line\">  │                  │       </div><div class=\"line\">┌───────┐          ┌───────┐   </div><div class=\"line\">│       │          │       │   </div><div class=\"line\">│ Data1 │◀────────▶│ Data2 │   </div><div class=\"line\">│       │          │       │   </div><div class=\"line\">└───────┘          └───────┘</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"写过程\"><a href=\"#写过程\" class=\"headerlink\" title=\"写过程\"></a>写过程</h3><p>数据的分布。 有两级划分，先时间段划分成shardgroup，每个里面包含一段时间内的数据。<br>时间段长度有创建的rp决定。再按照数据的measurement+tags进行hash后划分，分配到每个shard。<br>每个shard落在具体的datanode机器上。</p>\n<p>shardgroup里shard个数由总机器数/复制因子算出来，取整数。每个shard根据配置的复制因子再确定出所属的<br>datanode机器。  </p>\n<p>因此写入数据时，由datanode接收写请求，根据写请求参数查询meta信息（本地缓存或者meta node）。<br>结合meta信息，对于每个点，先根据timestamp路由到对应的shardgroup，再根据measurement+tags<br>路由到shard，最后在把数据分别发送给对应的datanode，剩下的就是单机的写入流程。</p>\n<p>前述这些shardgorup，shard在创建shardgroup时创建好的。上述关联信息都保存在metanode中。</p>\n<h3 id=\"读过程\"><a href=\"#读过程\" class=\"headerlink\" title=\"读过程\"></a>读过程</h3><p>   读数据也是由datanode处理的， 请求可以落到任意一台datanode上，和Cassandra很类似。<br>根据读请求查询meta信息（本地缓存或者meta node），根据时间的start，end确定shardgroup，<br>然后再找到shardgroup下所有的shard，再从shard关联的datanode中选择其中一个放入请求列表，<br>然后并行把请求发送给实际存储数据的datanode，最后合并分布式查询结果，并返回给客户端。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ol>\n<li><a href=\"https://groups.google.com/forum/#!msg/influxdb/3jQQMXmXd6Q/cGcmFjM-f8YJ\" target=\"_blank\" rel=\"noopener\">first:google gorup</a></li>\n<li><a href=\"https://www.influxdata.com/blog/clustering-tags-and-enhancements-to-come-in-0-9-0/#signup\" target=\"_blank\" rel=\"noopener\">0.9.0</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><ol>\n<li>meta node：元数据的写，读。</li>\n<li>data node：数据的写，读<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">┌───────┐     ┌───────┐      </div><div class=\"line\">│       │     │       │      </div><div class=\"line\">│ Meta1 │◀───▶│ Meta2 │      </div><div class=\"line\">│       │     │       │      </div><div class=\"line\">└───────┘     └───────┘      </div><div class=\"line\">    ▲             ▲          </div><div class=\"line\">    │             │          </div><div class=\"line\">    │  ┌───────┐  │          </div><div class=\"line\">    │  │       │  │          </div><div class=\"line\">    └─▶│ Meta3 │◀─┘          </div><div class=\"line\">       │       │             </div><div class=\"line\">       └───────┘             </div><div class=\"line\"></div><div class=\"line\">─────────────────────────────────</div><div class=\"line\">      ╲│╱    ╲│╱             </div><div class=\"line\">  ┌────┘      └──────┐       </div><div class=\"line\">  │                  │       </div><div class=\"line\">┌───────┐          ┌───────┐   </div><div class=\"line\">│       │          │       │   </div><div class=\"line\">│ Data1 │◀────────▶│ Data2 │   </div><div class=\"line\">│       │          │       │   </div><div class=\"line\">└───────┘          └───────┘</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"写过程\"><a href=\"#写过程\" class=\"headerlink\" title=\"写过程\"></a>写过程</h3><p>数据的分布。 有两级划分，先时间段划分成shardgroup，每个里面包含一段时间内的数据。<br>时间段长度有创建的rp决定。再按照数据的measurement+tags进行hash后划分，分配到每个shard。<br>每个shard落在具体的datanode机器上。</p>\n<p>shardgroup里shard个数由总机器数/复制因子算出来，取整数。每个shard根据配置的复制因子再确定出所属的<br>datanode机器。  </p>\n<p>因此写入数据时，由datanode接收写请求，根据写请求参数查询meta信息（本地缓存或者meta node）。<br>结合meta信息，对于每个点，先根据timestamp路由到对应的shardgroup，再根据measurement+tags<br>路由到shard，最后在把数据分别发送给对应的datanode，剩下的就是单机的写入流程。</p>\n<p>前述这些shardgorup，shard在创建shardgroup时创建好的。上述关联信息都保存在metanode中。</p>\n<h3 id=\"读过程\"><a href=\"#读过程\" class=\"headerlink\" title=\"读过程\"></a>读过程</h3><p>   读数据也是由datanode处理的， 请求可以落到任意一台datanode上，和Cassandra很类似。<br>根据读请求查询meta信息（本地缓存或者meta node），根据时间的start，end确定shardgroup，<br>然后再找到shardgroup下所有的shard，再从shard关联的datanode中选择其中一个放入请求列表，<br>然后并行把请求发送给实际存储数据的datanode，最后合并分布式查询结果，并返回给客户端。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ol>\n<li><a href=\"https://groups.google.com/forum/#!msg/influxdb/3jQQMXmXd6Q/cGcmFjM-f8YJ\" target=\"_blank\" rel=\"noopener\">first:google gorup</a></li>\n<li><a href=\"https://www.influxdata.com/blog/clustering-tags-and-enhancements-to-come-in-0-9-0/#signup\" target=\"_blank\" rel=\"noopener\">0.9.0</a></li>\n</ol>\n"},{"title":"20171113-misc","date":"2017-11-13T02:11:47.000Z","_content":"\n### goland下载失败解决办法\ngoland是个很好用的go语言ide，推荐使用。目前还是试用预览的EAP版本，直接在官方网站下载，\n在我的笔记本上，会报500错误。    \n```\n{\"errors\":[{\"code\":500,\"message\":\"Index: 0, Size: 0\"}]}\n```\n\n解决办法：\n1. 找到直接下载地址，见下面。\n2. 到官网下载页找到最新的版本号，比如73.3415.23。\n3. 替换下载地址里的版本为最新的，然后使用迅雷下载。\n4. 预览版一般只有1-2月的使用期限，到期后找到新版本号，重新下载即可。\n```\n不同平台的直接下载链接:\nhttp://download.jetbrains.com/go/gogland-163.10154.18.dmg\nhttp://download.jetbrains.com/go/gogland-163.10154.18.exe\nhttp://download.jetbrains.com/go/gogland-163.10154.18.tar.gz\n```\n","source":"_posts/2017-11-13-misc.md","raw":"---\ntitle: 20171113-misc\ndate: 2017-11-13 10:11:47\ntags:\n---\n\n### goland下载失败解决办法\ngoland是个很好用的go语言ide，推荐使用。目前还是试用预览的EAP版本，直接在官方网站下载，\n在我的笔记本上，会报500错误。    \n```\n{\"errors\":[{\"code\":500,\"message\":\"Index: 0, Size: 0\"}]}\n```\n\n解决办法：\n1. 找到直接下载地址，见下面。\n2. 到官网下载页找到最新的版本号，比如73.3415.23。\n3. 替换下载地址里的版本为最新的，然后使用迅雷下载。\n4. 预览版一般只有1-2月的使用期限，到期后找到新版本号，重新下载即可。\n```\n不同平台的直接下载链接:\nhttp://download.jetbrains.com/go/gogland-163.10154.18.dmg\nhttp://download.jetbrains.com/go/gogland-163.10154.18.exe\nhttp://download.jetbrains.com/go/gogland-163.10154.18.tar.gz\n```\n","slug":"misc","published":1,"updated":"2018-02-27T09:05:10.573Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje5g49gg0008h2vlw157dw41","content":"<h3 id=\"goland下载失败解决办法\"><a href=\"#goland下载失败解决办法\" class=\"headerlink\" title=\"goland下载失败解决办法\"></a>goland下载失败解决办法</h3><p>goland是个很好用的go语言ide，推荐使用。目前还是试用预览的EAP版本，直接在官方网站下载，<br>在我的笔记本上，会报500错误。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&quot;errors&quot;:[&#123;&quot;code&quot;:500,&quot;message&quot;:&quot;Index: 0, Size: 0&quot;&#125;]&#125;</div></pre></td></tr></table></figure></p>\n<p>解决办法：</p>\n<ol>\n<li>找到直接下载地址，见下面。</li>\n<li>到官网下载页找到最新的版本号，比如73.3415.23。</li>\n<li>替换下载地址里的版本为最新的，然后使用迅雷下载。</li>\n<li>预览版一般只有1-2月的使用期限，到期后找到新版本号，重新下载即可。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">不同平台的直接下载链接:</div><div class=\"line\">http://download.jetbrains.com/go/gogland-163.10154.18.dmg</div><div class=\"line\">http://download.jetbrains.com/go/gogland-163.10154.18.exe</div><div class=\"line\">http://download.jetbrains.com/go/gogland-163.10154.18.tar.gz</div></pre></td></tr></table></figure>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"goland下载失败解决办法\"><a href=\"#goland下载失败解决办法\" class=\"headerlink\" title=\"goland下载失败解决办法\"></a>goland下载失败解决办法</h3><p>goland是个很好用的go语言ide，推荐使用。目前还是试用预览的EAP版本，直接在官方网站下载，<br>在我的笔记本上，会报500错误。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&quot;errors&quot;:[&#123;&quot;code&quot;:500,&quot;message&quot;:&quot;Index: 0, Size: 0&quot;&#125;]&#125;</div></pre></td></tr></table></figure></p>\n<p>解决办法：</p>\n<ol>\n<li>找到直接下载地址，见下面。</li>\n<li>到官网下载页找到最新的版本号，比如73.3415.23。</li>\n<li>替换下载地址里的版本为最新的，然后使用迅雷下载。</li>\n<li>预览版一般只有1-2月的使用期限，到期后找到新版本号，重新下载即可。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">不同平台的直接下载链接:</div><div class=\"line\">http://download.jetbrains.com/go/gogland-163.10154.18.dmg</div><div class=\"line\">http://download.jetbrains.com/go/gogland-163.10154.18.exe</div><div class=\"line\">http://download.jetbrains.com/go/gogland-163.10154.18.tar.gz</div></pre></td></tr></table></figure>\n</li>\n</ol>\n"},{"title":"raft源码解读","date":"2017-11-27T06:07:13.000Z","_content":"以下是 hashicorp/raft 1.0 第一次源码阅读后的整理。根据经验，最开始往往有理解不正确的地方，后续加深理解后再整理修正，并与当前对比\n\n## 1. Apply过程\n### 1.1 leader\n- api.Apply 写logfuture到r.applyCh\n- raft.leaderLoop 读applyCh然后调用 dispatchLogs\n- raft.dispatchLogs 先写入到leaderStare的inflight,再持久化到logStore，然后通知commit(commitCh)，最后通知复制log(triggerCh)\n- 先说commit链路。raft.leaderLoop处理commit，循环从leaderState中读出每个待提交的LogFuture,然后调用r.processLogs\n- raft.processLogs循环调用processLog，里面向fsmMutateCh写入构造的commitTuple消息\n- fsm.runFSM读fsmMutateCh，执行commit函数，这个函数里面调用fsm对象的Apply方法，这个方法需要由用户自定义实现。\n- 再回到复制链路。启动时，每个follower都创建1个goroutine，运行r.replicate函数\n- 获得lastIndex，构造tranReq，r.setupAppendEntries从logstore读出需复制的log\n- r.trans.AppendEntries 执行RPC\n- commit补充。leader被通知commitCh，是当大多数follower复制成功消息后才被通知提交的。\n- 复制链路有个commitTimeout(默认50ms), 定期把当前的commitIndex等信息通过RPC传递到Follower。Command类型还是AppendEntriesRequest\n\n### 1.2 Follower\n- raft.runFollower 读r.rpcCh，然后调用processRPC处理\n- 检查rpc的类型，处理AppendEntriesRequest\n- 检查一大堆，然后先持久化到logStore，再commit。\n- commit过程与leader类似，调用processLogs进行处理。\n\n## 2. Term变化过程\n- 先进入到 Candidate 状态\n- 选举自己。发送投票请求给其它节点，请求包括currentTerm，lastTerm,lastIndex.\n- 优先投票给currentTerm，lastTerm，lastIndex最大的node\n\n## 3. Node变化过程\n- 添加节点。api.AddVoter必须在leader执行. 先更新configurations，接着调用dispatchLogs;\n调用startStopReplication 启动新节点的复制goroutine。\n- 删除节点。api.RemoveServer也必须在leader执行。流程和添加节点类似，commandType 变成RemoveServer。\n删除leader节点，触发重新选举。处理完log提交后，修改状态 stepdown 为true，然后关闭或者变成Follower。\n- 节点故障。 Follower的心跳超时，改变状态为 Candidate 重新选举。\n\n## 4. snapshot 过程\n- r.runSnapshots 默认每隔120s 检查一次上次snapshot的index和当前最新的index，二者差值超过8192，执行snapshot\n- 先创建snapshot的sink，然后持久化，再接着compactLog(删除已经snapshot的log)\n- 无论leader还是Follower都启动snapshot的goroutine\n\n## 5. restore 过程\n- 新加入的节点，状态为Fllower\n- leader主动同步log到新节点\n- 构造复制请求时，发现需要同步很久以前的log，且当前logstore不存在该log\n- 此时发起installSnapshot的请求给Follower，取消同步log的请求\n- follwer接收snapshot并应用到本地\n- leader的周期同步commit的机制逐步把最近的log同步给Follower\n","source":"_posts/2017-11-27-raft.md","raw":"---\ntitle: raft源码解读\ndate: 2017-11-27 14:07:13\ntags:\n---\n以下是 hashicorp/raft 1.0 第一次源码阅读后的整理。根据经验，最开始往往有理解不正确的地方，后续加深理解后再整理修正，并与当前对比\n\n## 1. Apply过程\n### 1.1 leader\n- api.Apply 写logfuture到r.applyCh\n- raft.leaderLoop 读applyCh然后调用 dispatchLogs\n- raft.dispatchLogs 先写入到leaderStare的inflight,再持久化到logStore，然后通知commit(commitCh)，最后通知复制log(triggerCh)\n- 先说commit链路。raft.leaderLoop处理commit，循环从leaderState中读出每个待提交的LogFuture,然后调用r.processLogs\n- raft.processLogs循环调用processLog，里面向fsmMutateCh写入构造的commitTuple消息\n- fsm.runFSM读fsmMutateCh，执行commit函数，这个函数里面调用fsm对象的Apply方法，这个方法需要由用户自定义实现。\n- 再回到复制链路。启动时，每个follower都创建1个goroutine，运行r.replicate函数\n- 获得lastIndex，构造tranReq，r.setupAppendEntries从logstore读出需复制的log\n- r.trans.AppendEntries 执行RPC\n- commit补充。leader被通知commitCh，是当大多数follower复制成功消息后才被通知提交的。\n- 复制链路有个commitTimeout(默认50ms), 定期把当前的commitIndex等信息通过RPC传递到Follower。Command类型还是AppendEntriesRequest\n\n### 1.2 Follower\n- raft.runFollower 读r.rpcCh，然后调用processRPC处理\n- 检查rpc的类型，处理AppendEntriesRequest\n- 检查一大堆，然后先持久化到logStore，再commit。\n- commit过程与leader类似，调用processLogs进行处理。\n\n## 2. Term变化过程\n- 先进入到 Candidate 状态\n- 选举自己。发送投票请求给其它节点，请求包括currentTerm，lastTerm,lastIndex.\n- 优先投票给currentTerm，lastTerm，lastIndex最大的node\n\n## 3. Node变化过程\n- 添加节点。api.AddVoter必须在leader执行. 先更新configurations，接着调用dispatchLogs;\n调用startStopReplication 启动新节点的复制goroutine。\n- 删除节点。api.RemoveServer也必须在leader执行。流程和添加节点类似，commandType 变成RemoveServer。\n删除leader节点，触发重新选举。处理完log提交后，修改状态 stepdown 为true，然后关闭或者变成Follower。\n- 节点故障。 Follower的心跳超时，改变状态为 Candidate 重新选举。\n\n## 4. snapshot 过程\n- r.runSnapshots 默认每隔120s 检查一次上次snapshot的index和当前最新的index，二者差值超过8192，执行snapshot\n- 先创建snapshot的sink，然后持久化，再接着compactLog(删除已经snapshot的log)\n- 无论leader还是Follower都启动snapshot的goroutine\n\n## 5. restore 过程\n- 新加入的节点，状态为Fllower\n- leader主动同步log到新节点\n- 构造复制请求时，发现需要同步很久以前的log，且当前logstore不存在该log\n- 此时发起installSnapshot的请求给Follower，取消同步log的请求\n- follwer接收snapshot并应用到本地\n- leader的周期同步commit的机制逐步把最近的log同步给Follower\n","slug":"raft","published":1,"updated":"2018-02-27T09:05:10.573Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje5g49gk000ch2vl9po0j4xy","content":"<p>以下是 hashicorp/raft 1.0 第一次源码阅读后的整理。根据经验，最开始往往有理解不正确的地方，后续加深理解后再整理修正，并与当前对比</p>\n<h2 id=\"1-Apply过程\"><a href=\"#1-Apply过程\" class=\"headerlink\" title=\"1. Apply过程\"></a>1. Apply过程</h2><h3 id=\"1-1-leader\"><a href=\"#1-1-leader\" class=\"headerlink\" title=\"1.1 leader\"></a>1.1 leader</h3><ul>\n<li>api.Apply 写logfuture到r.applyCh</li>\n<li>raft.leaderLoop 读applyCh然后调用 dispatchLogs</li>\n<li>raft.dispatchLogs 先写入到leaderStare的inflight,再持久化到logStore，然后通知commit(commitCh)，最后通知复制log(triggerCh)</li>\n<li>先说commit链路。raft.leaderLoop处理commit，循环从leaderState中读出每个待提交的LogFuture,然后调用r.processLogs</li>\n<li>raft.processLogs循环调用processLog，里面向fsmMutateCh写入构造的commitTuple消息</li>\n<li>fsm.runFSM读fsmMutateCh，执行commit函数，这个函数里面调用fsm对象的Apply方法，这个方法需要由用户自定义实现。</li>\n<li>再回到复制链路。启动时，每个follower都创建1个goroutine，运行r.replicate函数</li>\n<li>获得lastIndex，构造tranReq，r.setupAppendEntries从logstore读出需复制的log</li>\n<li>r.trans.AppendEntries 执行RPC</li>\n<li>commit补充。leader被通知commitCh，是当大多数follower复制成功消息后才被通知提交的。</li>\n<li>复制链路有个commitTimeout(默认50ms), 定期把当前的commitIndex等信息通过RPC传递到Follower。Command类型还是AppendEntriesRequest</li>\n</ul>\n<h3 id=\"1-2-Follower\"><a href=\"#1-2-Follower\" class=\"headerlink\" title=\"1.2 Follower\"></a>1.2 Follower</h3><ul>\n<li>raft.runFollower 读r.rpcCh，然后调用processRPC处理</li>\n<li>检查rpc的类型，处理AppendEntriesRequest</li>\n<li>检查一大堆，然后先持久化到logStore，再commit。</li>\n<li>commit过程与leader类似，调用processLogs进行处理。</li>\n</ul>\n<h2 id=\"2-Term变化过程\"><a href=\"#2-Term变化过程\" class=\"headerlink\" title=\"2. Term变化过程\"></a>2. Term变化过程</h2><ul>\n<li>先进入到 Candidate 状态</li>\n<li>选举自己。发送投票请求给其它节点，请求包括currentTerm，lastTerm,lastIndex.</li>\n<li>优先投票给currentTerm，lastTerm，lastIndex最大的node</li>\n</ul>\n<h2 id=\"3-Node变化过程\"><a href=\"#3-Node变化过程\" class=\"headerlink\" title=\"3. Node变化过程\"></a>3. Node变化过程</h2><ul>\n<li>添加节点。api.AddVoter必须在leader执行. 先更新configurations，接着调用dispatchLogs;<br>调用startStopReplication 启动新节点的复制goroutine。</li>\n<li>删除节点。api.RemoveServer也必须在leader执行。流程和添加节点类似，commandType 变成RemoveServer。<br>删除leader节点，触发重新选举。处理完log提交后，修改状态 stepdown 为true，然后关闭或者变成Follower。</li>\n<li>节点故障。 Follower的心跳超时，改变状态为 Candidate 重新选举。</li>\n</ul>\n<h2 id=\"4-snapshot-过程\"><a href=\"#4-snapshot-过程\" class=\"headerlink\" title=\"4. snapshot 过程\"></a>4. snapshot 过程</h2><ul>\n<li>r.runSnapshots 默认每隔120s 检查一次上次snapshot的index和当前最新的index，二者差值超过8192，执行snapshot</li>\n<li>先创建snapshot的sink，然后持久化，再接着compactLog(删除已经snapshot的log)</li>\n<li>无论leader还是Follower都启动snapshot的goroutine</li>\n</ul>\n<h2 id=\"5-restore-过程\"><a href=\"#5-restore-过程\" class=\"headerlink\" title=\"5. restore 过程\"></a>5. restore 过程</h2><ul>\n<li>新加入的节点，状态为Fllower</li>\n<li>leader主动同步log到新节点</li>\n<li>构造复制请求时，发现需要同步很久以前的log，且当前logstore不存在该log</li>\n<li>此时发起installSnapshot的请求给Follower，取消同步log的请求</li>\n<li>follwer接收snapshot并应用到本地</li>\n<li>leader的周期同步commit的机制逐步把最近的log同步给Follower</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>以下是 hashicorp/raft 1.0 第一次源码阅读后的整理。根据经验，最开始往往有理解不正确的地方，后续加深理解后再整理修正，并与当前对比</p>\n<h2 id=\"1-Apply过程\"><a href=\"#1-Apply过程\" class=\"headerlink\" title=\"1. Apply过程\"></a>1. Apply过程</h2><h3 id=\"1-1-leader\"><a href=\"#1-1-leader\" class=\"headerlink\" title=\"1.1 leader\"></a>1.1 leader</h3><ul>\n<li>api.Apply 写logfuture到r.applyCh</li>\n<li>raft.leaderLoop 读applyCh然后调用 dispatchLogs</li>\n<li>raft.dispatchLogs 先写入到leaderStare的inflight,再持久化到logStore，然后通知commit(commitCh)，最后通知复制log(triggerCh)</li>\n<li>先说commit链路。raft.leaderLoop处理commit，循环从leaderState中读出每个待提交的LogFuture,然后调用r.processLogs</li>\n<li>raft.processLogs循环调用processLog，里面向fsmMutateCh写入构造的commitTuple消息</li>\n<li>fsm.runFSM读fsmMutateCh，执行commit函数，这个函数里面调用fsm对象的Apply方法，这个方法需要由用户自定义实现。</li>\n<li>再回到复制链路。启动时，每个follower都创建1个goroutine，运行r.replicate函数</li>\n<li>获得lastIndex，构造tranReq，r.setupAppendEntries从logstore读出需复制的log</li>\n<li>r.trans.AppendEntries 执行RPC</li>\n<li>commit补充。leader被通知commitCh，是当大多数follower复制成功消息后才被通知提交的。</li>\n<li>复制链路有个commitTimeout(默认50ms), 定期把当前的commitIndex等信息通过RPC传递到Follower。Command类型还是AppendEntriesRequest</li>\n</ul>\n<h3 id=\"1-2-Follower\"><a href=\"#1-2-Follower\" class=\"headerlink\" title=\"1.2 Follower\"></a>1.2 Follower</h3><ul>\n<li>raft.runFollower 读r.rpcCh，然后调用processRPC处理</li>\n<li>检查rpc的类型，处理AppendEntriesRequest</li>\n<li>检查一大堆，然后先持久化到logStore，再commit。</li>\n<li>commit过程与leader类似，调用processLogs进行处理。</li>\n</ul>\n<h2 id=\"2-Term变化过程\"><a href=\"#2-Term变化过程\" class=\"headerlink\" title=\"2. Term变化过程\"></a>2. Term变化过程</h2><ul>\n<li>先进入到 Candidate 状态</li>\n<li>选举自己。发送投票请求给其它节点，请求包括currentTerm，lastTerm,lastIndex.</li>\n<li>优先投票给currentTerm，lastTerm，lastIndex最大的node</li>\n</ul>\n<h2 id=\"3-Node变化过程\"><a href=\"#3-Node变化过程\" class=\"headerlink\" title=\"3. Node变化过程\"></a>3. Node变化过程</h2><ul>\n<li>添加节点。api.AddVoter必须在leader执行. 先更新configurations，接着调用dispatchLogs;<br>调用startStopReplication 启动新节点的复制goroutine。</li>\n<li>删除节点。api.RemoveServer也必须在leader执行。流程和添加节点类似，commandType 变成RemoveServer。<br>删除leader节点，触发重新选举。处理完log提交后，修改状态 stepdown 为true，然后关闭或者变成Follower。</li>\n<li>节点故障。 Follower的心跳超时，改变状态为 Candidate 重新选举。</li>\n</ul>\n<h2 id=\"4-snapshot-过程\"><a href=\"#4-snapshot-过程\" class=\"headerlink\" title=\"4. snapshot 过程\"></a>4. snapshot 过程</h2><ul>\n<li>r.runSnapshots 默认每隔120s 检查一次上次snapshot的index和当前最新的index，二者差值超过8192，执行snapshot</li>\n<li>先创建snapshot的sink，然后持久化，再接着compactLog(删除已经snapshot的log)</li>\n<li>无论leader还是Follower都启动snapshot的goroutine</li>\n</ul>\n<h2 id=\"5-restore-过程\"><a href=\"#5-restore-过程\" class=\"headerlink\" title=\"5. restore 过程\"></a>5. restore 过程</h2><ul>\n<li>新加入的节点，状态为Fllower</li>\n<li>leader主动同步log到新节点</li>\n<li>构造复制请求时，发现需要同步很久以前的log，且当前logstore不存在该log</li>\n<li>此时发起installSnapshot的请求给Follower，取消同步log的请求</li>\n<li>follwer接收snapshot并应用到本地</li>\n<li>leader的周期同步commit的机制逐步把最近的log同步给Follower</li>\n</ul>\n"},{"title":"influxdb_monitor","date":"2018-02-27T11:49:45.000Z","_content":"## 1. 前言\n  无论是开发还是运维，对于influxd(InfluxDb服务端)的运行状态信息的获取都是至关重要的。\n在influxd内部把监控信息分成了两大类: Diagnostics 和 Statistics 。 这些信息默认是持久化到\ninfluxdb内的，对应得database是 `_internal` ， 每隔10s写入一次。\n\n\n## 2. Statistics\n  Statistics信息是可以计数的数字，需要定期存储起来以便事后分析。例如写入点的个数，查询请求数等。  \n\n### 2.1 查询statistics\n1. 在console执行命令。 SHOW STATS\n2. 读http服务。 curl http://localhost:8086/debug/vars\n\n### 2.2 添加statistics\n对于新创建的服务，添加Statistics信息。参考以下步骤:\n1. 定义Statistics结构，并作为的服务的Field之一。\n```\ntype ShardWriteStatistics struct {\n\tDirectWriteReq      int64\n\tFlushWriteReq int64\n\tFlushCount  int64\n}\n```\n2. 在服务相关的地方执行原子计数增加。  \n```\natomic.AddInt64(&w.stats.FlushCount, 1)\n```\n3. 实现接口 monitor.Reporter。\n```\nfunc (w *ShardWriter) Statistics(tags map[string]string) []models.Statistic {\n\treturn []models.Statistic{{\n\t\tName: \"shard_write\",\n\t\tTags: tags,\n\t\tValues: map[string]interface{}{\n\t\t\tdirectWriteReq:    atomic.LoadInt64(&w.stats.DirectWriteReq),\n\t\t\tflushWriteReq:     atomic.LoadInt64(&w.stats.FlushWriteReq),\n\t\t\tflushCount:        atomic.LoadInt64(&w.stats.FlushCount),\n\t\t},\n\t}}\n}\n```\n4. 透出statistics信息。如果新服务实现了service接口，默认会注册到server的;其他情况可以在Server的Statistics方法中调用，并append到\n最终结果中。\n```\nstatistics = append(statistics, s.ShardWriter.Statistics(tags)...)\n```\n\n## 3. Diagnostics\n  Diagnostics信息可以不是数字，也不需要存储，一般在内存中。例如influxd版本信息，各个service\n的配置信息等。\n\n### 3.1 查询diagnostics\n1. 在console执行命令。 SHOW DIAGNOSTICS\n\n### 3.2 添加diagnostics\n  对于新创建的服务的配置信息或者运行时参数，可以作为diagnostics信息透出。可按下面步骤添加\n1. 对新服务的config结构，实现接口 diagnostics.Client\n```\nfunc (c Config) Diagnostics() (*diagnostics.Diagnostics, error) {\n\treturn diagnostics.RowFromMap(map[string]interface{}{\n\t\t\"write-timeout\":          c.WriteTimeout,\n\t\t\"max-concurrent-queries\": c.MaxConcurrentQueries,\n\t\t\"query-timeout\":          c.QueryTimeout,\n\t\t\"log-queries-after\":      c.LogQueriesAfter,\n\t\t\"max-select-point\":       c.MaxSelectPointN,\n\t\t\"max-select-series\":      c.MaxSelectSeriesN,\n\t\t\"max-select-buckets\":     c.MaxSelectBucketsN,\n\t}), nil\n}\n```\n2. 在run包的config.go中的diagnosticsClients添加\n```\nfunc (c *Config) diagnosticsClients() map[string]diagnostics.Client {\n \tm := map[string]diagnostics.Client{\n\t\t\"config\": c,\n\t\t\"config-data\":        c.Data,\n\n\t\t\"config-dataext\":        c.DataExt,  // added config\n\n\t\t\"config-meta\":        c.Meta,\n\t\t\"config-retention\":   c.Retention,\n\t\t\"config-precreator\":  c.Precreator,\n\t\t\"config-monitor\":    c.Monitor,\n\t\t\"config-httpd\":      c.HTTPD,\n\t\t}\n\treturn m\n}\n```\n\n\n## 4. References\n[Server monitoring](https://docs.influxdata.com/influxdb/v1.4/troubleshooting/statistics/)\n[System Monitoring](https://github.com/influxdata/influxdb/blob/master/monitor/README.md)\n[How to use the SHOW STATS command and the \\_internal database to monitor InfluxDB](https://www.influxdata.com/blog/how-to-use-the-show-stats-command-and-the-_internal-database-to-monitor-influxdb/)\n","source":"_posts/2018-02-27-influxdb-monitor.md","raw":"---\ntitle: influxdb_monitor\ndate: 2018-02-27 19:49:45\ntags:\n---\n## 1. 前言\n  无论是开发还是运维，对于influxd(InfluxDb服务端)的运行状态信息的获取都是至关重要的。\n在influxd内部把监控信息分成了两大类: Diagnostics 和 Statistics 。 这些信息默认是持久化到\ninfluxdb内的，对应得database是 `_internal` ， 每隔10s写入一次。\n\n\n## 2. Statistics\n  Statistics信息是可以计数的数字，需要定期存储起来以便事后分析。例如写入点的个数，查询请求数等。  \n\n### 2.1 查询statistics\n1. 在console执行命令。 SHOW STATS\n2. 读http服务。 curl http://localhost:8086/debug/vars\n\n### 2.2 添加statistics\n对于新创建的服务，添加Statistics信息。参考以下步骤:\n1. 定义Statistics结构，并作为的服务的Field之一。\n```\ntype ShardWriteStatistics struct {\n\tDirectWriteReq      int64\n\tFlushWriteReq int64\n\tFlushCount  int64\n}\n```\n2. 在服务相关的地方执行原子计数增加。  \n```\natomic.AddInt64(&w.stats.FlushCount, 1)\n```\n3. 实现接口 monitor.Reporter。\n```\nfunc (w *ShardWriter) Statistics(tags map[string]string) []models.Statistic {\n\treturn []models.Statistic{{\n\t\tName: \"shard_write\",\n\t\tTags: tags,\n\t\tValues: map[string]interface{}{\n\t\t\tdirectWriteReq:    atomic.LoadInt64(&w.stats.DirectWriteReq),\n\t\t\tflushWriteReq:     atomic.LoadInt64(&w.stats.FlushWriteReq),\n\t\t\tflushCount:        atomic.LoadInt64(&w.stats.FlushCount),\n\t\t},\n\t}}\n}\n```\n4. 透出statistics信息。如果新服务实现了service接口，默认会注册到server的;其他情况可以在Server的Statistics方法中调用，并append到\n最终结果中。\n```\nstatistics = append(statistics, s.ShardWriter.Statistics(tags)...)\n```\n\n## 3. Diagnostics\n  Diagnostics信息可以不是数字，也不需要存储，一般在内存中。例如influxd版本信息，各个service\n的配置信息等。\n\n### 3.1 查询diagnostics\n1. 在console执行命令。 SHOW DIAGNOSTICS\n\n### 3.2 添加diagnostics\n  对于新创建的服务的配置信息或者运行时参数，可以作为diagnostics信息透出。可按下面步骤添加\n1. 对新服务的config结构，实现接口 diagnostics.Client\n```\nfunc (c Config) Diagnostics() (*diagnostics.Diagnostics, error) {\n\treturn diagnostics.RowFromMap(map[string]interface{}{\n\t\t\"write-timeout\":          c.WriteTimeout,\n\t\t\"max-concurrent-queries\": c.MaxConcurrentQueries,\n\t\t\"query-timeout\":          c.QueryTimeout,\n\t\t\"log-queries-after\":      c.LogQueriesAfter,\n\t\t\"max-select-point\":       c.MaxSelectPointN,\n\t\t\"max-select-series\":      c.MaxSelectSeriesN,\n\t\t\"max-select-buckets\":     c.MaxSelectBucketsN,\n\t}), nil\n}\n```\n2. 在run包的config.go中的diagnosticsClients添加\n```\nfunc (c *Config) diagnosticsClients() map[string]diagnostics.Client {\n \tm := map[string]diagnostics.Client{\n\t\t\"config\": c,\n\t\t\"config-data\":        c.Data,\n\n\t\t\"config-dataext\":        c.DataExt,  // added config\n\n\t\t\"config-meta\":        c.Meta,\n\t\t\"config-retention\":   c.Retention,\n\t\t\"config-precreator\":  c.Precreator,\n\t\t\"config-monitor\":    c.Monitor,\n\t\t\"config-httpd\":      c.HTTPD,\n\t\t}\n\treturn m\n}\n```\n\n\n## 4. References\n[Server monitoring](https://docs.influxdata.com/influxdb/v1.4/troubleshooting/statistics/)\n[System Monitoring](https://github.com/influxdata/influxdb/blob/master/monitor/README.md)\n[How to use the SHOW STATS command and the \\_internal database to monitor InfluxDB](https://www.influxdata.com/blog/how-to-use-the-show-stats-command-and-the-_internal-database-to-monitor-influxdb/)\n","slug":"influxdb-monitor","published":1,"updated":"2018-03-06T08:49:02.068Z","_id":"cje5lazsw00006ifmz2lpzoej","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h2><p>  无论是开发还是运维，对于influxd(InfluxDb服务端)的运行状态信息的获取都是至关重要的。<br>在influxd内部把监控信息分成了两大类: Diagnostics 和 Statistics 。 这些信息默认是持久化到<br>influxdb内的，对应得database是 <code>_internal</code> ， 每隔10s写入一次。</p>\n<h2 id=\"2-Statistics\"><a href=\"#2-Statistics\" class=\"headerlink\" title=\"2. Statistics\"></a>2. Statistics</h2><p>  Statistics信息是可以计数的数字，需要定期存储起来以便事后分析。例如写入点的个数，查询请求数等。  </p>\n<h3 id=\"2-1-查询statistics\"><a href=\"#2-1-查询statistics\" class=\"headerlink\" title=\"2.1 查询statistics\"></a>2.1 查询statistics</h3><ol>\n<li>在console执行命令。 SHOW STATS</li>\n<li>读http服务。 curl <a href=\"http://localhost:8086/debug/vars\" target=\"_blank\" rel=\"noopener\">http://localhost:8086/debug/vars</a></li>\n</ol>\n<h3 id=\"2-2-添加statistics\"><a href=\"#2-2-添加statistics\" class=\"headerlink\" title=\"2.2 添加statistics\"></a>2.2 添加statistics</h3><p>对于新创建的服务，添加Statistics信息。参考以下步骤:</p>\n<ol>\n<li><p>定义Statistics结构，并作为的服务的Field之一。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">type ShardWriteStatistics struct &#123;</div><div class=\"line\">\tDirectWriteReq      int64</div><div class=\"line\">\tFlushWriteReq int64</div><div class=\"line\">\tFlushCount  int64</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>在服务相关的地方执行原子计数增加。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">atomic.AddInt64(&amp;w.stats.FlushCount, 1)</div></pre></td></tr></table></figure>\n</li>\n<li><p>实现接口 monitor.Reporter。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">func (w *ShardWriter) Statistics(tags map[string]string) []models.Statistic &#123;</div><div class=\"line\">\treturn []models.Statistic&#123;&#123;</div><div class=\"line\">\t\tName: &quot;shard_write&quot;,</div><div class=\"line\">\t\tTags: tags,</div><div class=\"line\">\t\tValues: map[string]interface&#123;&#125;&#123;</div><div class=\"line\">\t\t\tdirectWriteReq:    atomic.LoadInt64(&amp;w.stats.DirectWriteReq),</div><div class=\"line\">\t\t\tflushWriteReq:     atomic.LoadInt64(&amp;w.stats.FlushWriteReq),</div><div class=\"line\">\t\t\tflushCount:        atomic.LoadInt64(&amp;w.stats.FlushCount),</div><div class=\"line\">\t\t&#125;,</div><div class=\"line\">\t&#125;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>透出statistics信息。如果新服务实现了service接口，默认会注册到server的;其他情况可以在Server的Statistics方法中调用，并append到<br>最终结果中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">statistics = append(statistics, s.ShardWriter.Statistics(tags)...)</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"3-Diagnostics\"><a href=\"#3-Diagnostics\" class=\"headerlink\" title=\"3. Diagnostics\"></a>3. Diagnostics</h2><p>  Diagnostics信息可以不是数字，也不需要存储，一般在内存中。例如influxd版本信息，各个service<br>的配置信息等。</p>\n<h3 id=\"3-1-查询diagnostics\"><a href=\"#3-1-查询diagnostics\" class=\"headerlink\" title=\"3.1 查询diagnostics\"></a>3.1 查询diagnostics</h3><ol>\n<li>在console执行命令。 SHOW DIAGNOSTICS</li>\n</ol>\n<h3 id=\"3-2-添加diagnostics\"><a href=\"#3-2-添加diagnostics\" class=\"headerlink\" title=\"3.2 添加diagnostics\"></a>3.2 添加diagnostics</h3><p>  对于新创建的服务的配置信息或者运行时参数，可以作为diagnostics信息透出。可按下面步骤添加</p>\n<ol>\n<li><p>对新服务的config结构，实现接口 diagnostics.Client</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">func (c Config) Diagnostics() (*diagnostics.Diagnostics, error) &#123;</div><div class=\"line\">\treturn diagnostics.RowFromMap(map[string]interface&#123;&#125;&#123;</div><div class=\"line\">\t\t&quot;write-timeout&quot;:          c.WriteTimeout,</div><div class=\"line\">\t\t&quot;max-concurrent-queries&quot;: c.MaxConcurrentQueries,</div><div class=\"line\">\t\t&quot;query-timeout&quot;:          c.QueryTimeout,</div><div class=\"line\">\t\t&quot;log-queries-after&quot;:      c.LogQueriesAfter,</div><div class=\"line\">\t\t&quot;max-select-point&quot;:       c.MaxSelectPointN,</div><div class=\"line\">\t\t&quot;max-select-series&quot;:      c.MaxSelectSeriesN,</div><div class=\"line\">\t\t&quot;max-select-buckets&quot;:     c.MaxSelectBucketsN,</div><div class=\"line\">\t&#125;), nil</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>在run包的config.go中的diagnosticsClients添加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">func (c *Config) diagnosticsClients() map[string]diagnostics.Client &#123;</div><div class=\"line\"> \tm := map[string]diagnostics.Client&#123;</div><div class=\"line\">\t\t&quot;config&quot;: c,</div><div class=\"line\">\t\t&quot;config-data&quot;:        c.Data,</div><div class=\"line\"></div><div class=\"line\">\t\t&quot;config-dataext&quot;:        c.DataExt,  // added config</div><div class=\"line\"></div><div class=\"line\">\t\t&quot;config-meta&quot;:        c.Meta,</div><div class=\"line\">\t\t&quot;config-retention&quot;:   c.Retention,</div><div class=\"line\">\t\t&quot;config-precreator&quot;:  c.Precreator,</div><div class=\"line\">\t\t&quot;config-monitor&quot;:    c.Monitor,</div><div class=\"line\">\t\t&quot;config-httpd&quot;:      c.HTTPD,</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\treturn m</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"4-References\"><a href=\"#4-References\" class=\"headerlink\" title=\"4. References\"></a>4. References</h2><p><a href=\"https://docs.influxdata.com/influxdb/v1.4/troubleshooting/statistics/\" target=\"_blank\" rel=\"noopener\">Server monitoring</a><br><a href=\"https://github.com/influxdata/influxdb/blob/master/monitor/README.md\" target=\"_blank\" rel=\"noopener\">System Monitoring</a><br><a href=\"https://www.influxdata.com/blog/how-to-use-the-show-stats-command-and-the-_internal-database-to-monitor-influxdb/\" target=\"_blank\" rel=\"noopener\">How to use the SHOW STATS command and the _internal database to monitor InfluxDB</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h2><p>  无论是开发还是运维，对于influxd(InfluxDb服务端)的运行状态信息的获取都是至关重要的。<br>在influxd内部把监控信息分成了两大类: Diagnostics 和 Statistics 。 这些信息默认是持久化到<br>influxdb内的，对应得database是 <code>_internal</code> ， 每隔10s写入一次。</p>\n<h2 id=\"2-Statistics\"><a href=\"#2-Statistics\" class=\"headerlink\" title=\"2. Statistics\"></a>2. Statistics</h2><p>  Statistics信息是可以计数的数字，需要定期存储起来以便事后分析。例如写入点的个数，查询请求数等。  </p>\n<h3 id=\"2-1-查询statistics\"><a href=\"#2-1-查询statistics\" class=\"headerlink\" title=\"2.1 查询statistics\"></a>2.1 查询statistics</h3><ol>\n<li>在console执行命令。 SHOW STATS</li>\n<li>读http服务。 curl <a href=\"http://localhost:8086/debug/vars\" target=\"_blank\" rel=\"noopener\">http://localhost:8086/debug/vars</a></li>\n</ol>\n<h3 id=\"2-2-添加statistics\"><a href=\"#2-2-添加statistics\" class=\"headerlink\" title=\"2.2 添加statistics\"></a>2.2 添加statistics</h3><p>对于新创建的服务，添加Statistics信息。参考以下步骤:</p>\n<ol>\n<li><p>定义Statistics结构，并作为的服务的Field之一。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">type ShardWriteStatistics struct &#123;</div><div class=\"line\">\tDirectWriteReq      int64</div><div class=\"line\">\tFlushWriteReq int64</div><div class=\"line\">\tFlushCount  int64</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>在服务相关的地方执行原子计数增加。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">atomic.AddInt64(&amp;w.stats.FlushCount, 1)</div></pre></td></tr></table></figure>\n</li>\n<li><p>实现接口 monitor.Reporter。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">func (w *ShardWriter) Statistics(tags map[string]string) []models.Statistic &#123;</div><div class=\"line\">\treturn []models.Statistic&#123;&#123;</div><div class=\"line\">\t\tName: &quot;shard_write&quot;,</div><div class=\"line\">\t\tTags: tags,</div><div class=\"line\">\t\tValues: map[string]interface&#123;&#125;&#123;</div><div class=\"line\">\t\t\tdirectWriteReq:    atomic.LoadInt64(&amp;w.stats.DirectWriteReq),</div><div class=\"line\">\t\t\tflushWriteReq:     atomic.LoadInt64(&amp;w.stats.FlushWriteReq),</div><div class=\"line\">\t\t\tflushCount:        atomic.LoadInt64(&amp;w.stats.FlushCount),</div><div class=\"line\">\t\t&#125;,</div><div class=\"line\">\t&#125;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>透出statistics信息。如果新服务实现了service接口，默认会注册到server的;其他情况可以在Server的Statistics方法中调用，并append到<br>最终结果中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">statistics = append(statistics, s.ShardWriter.Statistics(tags)...)</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"3-Diagnostics\"><a href=\"#3-Diagnostics\" class=\"headerlink\" title=\"3. Diagnostics\"></a>3. Diagnostics</h2><p>  Diagnostics信息可以不是数字，也不需要存储，一般在内存中。例如influxd版本信息，各个service<br>的配置信息等。</p>\n<h3 id=\"3-1-查询diagnostics\"><a href=\"#3-1-查询diagnostics\" class=\"headerlink\" title=\"3.1 查询diagnostics\"></a>3.1 查询diagnostics</h3><ol>\n<li>在console执行命令。 SHOW DIAGNOSTICS</li>\n</ol>\n<h3 id=\"3-2-添加diagnostics\"><a href=\"#3-2-添加diagnostics\" class=\"headerlink\" title=\"3.2 添加diagnostics\"></a>3.2 添加diagnostics</h3><p>  对于新创建的服务的配置信息或者运行时参数，可以作为diagnostics信息透出。可按下面步骤添加</p>\n<ol>\n<li><p>对新服务的config结构，实现接口 diagnostics.Client</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">func (c Config) Diagnostics() (*diagnostics.Diagnostics, error) &#123;</div><div class=\"line\">\treturn diagnostics.RowFromMap(map[string]interface&#123;&#125;&#123;</div><div class=\"line\">\t\t&quot;write-timeout&quot;:          c.WriteTimeout,</div><div class=\"line\">\t\t&quot;max-concurrent-queries&quot;: c.MaxConcurrentQueries,</div><div class=\"line\">\t\t&quot;query-timeout&quot;:          c.QueryTimeout,</div><div class=\"line\">\t\t&quot;log-queries-after&quot;:      c.LogQueriesAfter,</div><div class=\"line\">\t\t&quot;max-select-point&quot;:       c.MaxSelectPointN,</div><div class=\"line\">\t\t&quot;max-select-series&quot;:      c.MaxSelectSeriesN,</div><div class=\"line\">\t\t&quot;max-select-buckets&quot;:     c.MaxSelectBucketsN,</div><div class=\"line\">\t&#125;), nil</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>在run包的config.go中的diagnosticsClients添加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">func (c *Config) diagnosticsClients() map[string]diagnostics.Client &#123;</div><div class=\"line\"> \tm := map[string]diagnostics.Client&#123;</div><div class=\"line\">\t\t&quot;config&quot;: c,</div><div class=\"line\">\t\t&quot;config-data&quot;:        c.Data,</div><div class=\"line\"></div><div class=\"line\">\t\t&quot;config-dataext&quot;:        c.DataExt,  // added config</div><div class=\"line\"></div><div class=\"line\">\t\t&quot;config-meta&quot;:        c.Meta,</div><div class=\"line\">\t\t&quot;config-retention&quot;:   c.Retention,</div><div class=\"line\">\t\t&quot;config-precreator&quot;:  c.Precreator,</div><div class=\"line\">\t\t&quot;config-monitor&quot;:    c.Monitor,</div><div class=\"line\">\t\t&quot;config-httpd&quot;:      c.HTTPD,</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\treturn m</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"4-References\"><a href=\"#4-References\" class=\"headerlink\" title=\"4. References\"></a>4. References</h2><p><a href=\"https://docs.influxdata.com/influxdb/v1.4/troubleshooting/statistics/\" target=\"_blank\" rel=\"noopener\">Server monitoring</a><br><a href=\"https://github.com/influxdata/influxdb/blob/master/monitor/README.md\" target=\"_blank\" rel=\"noopener\">System Monitoring</a><br><a href=\"https://www.influxdata.com/blog/how-to-use-the-show-stats-command-and-the-_internal-database-to-monitor-influxdb/\" target=\"_blank\" rel=\"noopener\">How to use the SHOW STATS command and the _internal database to monitor InfluxDB</a></p>\n"},{"title":"influx_stress造数据令人困惑的问题","date":"2017-10-18T12:47:59.000Z","_content":"\n## 1.简介\n  influx_stress是influxdb社区版里的一个命令。主要功能是可以解析一个脚本文件，然后执行里面的动作，包括造数据，写db，读db。\n从而对单机版进行读写压力测试。 目前有两个版本，其中v2性能更好一点。下面主要讨论v2版本存在的问题。\n\n## 2.造数据  \n### 2.1 问题    \n以下是官方文档的节选\n\n```\nYou can write points like this:\n\nINSERT mockCpu\ncpu,\nhost=server-[int inc(0) 100],location=[east|sourth|west|north]\nvalue=[float rand(1000) 0]\n100000 10s\n\nExplained:\n\n# INSERT keyword kicks off the statement, next to it is the name of the statement for reporting and templated query generation\nINSERT mockCpu\n# Measurement\ncpu,\n# Tags - separated by commas. Tag values can be templates, mixed template and fixed values\nhost=server-[float rand(100) 100],location=[int inc(0) 10],fixed=[fix|fid|dor|pom|another_tag_value]\n# Fields - separated by commas either templates, mixed template and fixed values\nvalue=[float inc(0) 0]\n# 'Timestamp' - Number of points to insert into this measurement and the amount of time between points\n100000 10s\n```  \n其中tags, fields支持模板，可以按照模板中的表达式生成对应的值。\n最后一行的100000， 表示制造的总数据量。\n看到文档， 想当然的以为插入的数据有100000行。实际执行select count后发现并不是这样， 上面这个例子最终只有25000行数据可以查询到。\n和预期的差太多了， 好奇怪。  \n\n翻了代码发现，在解析的过程中把每个模板表达式解析成1个模板函数。 例子有三个，两个tag和一个field。它是如何使用的呢？\n1. 根据tags的配置， 理论上应该有400个timeseries，因此会把100000分成250时间点。 每个时间点的数据时间戳相同， 包含400条数据。\n这个还是符合预期的。\n2. 生成每个时间点单个timeserie的数据，可以理解成db里的一行数据。依次调用模板函数，每个函数内部有个计数。当超过上限后恢复成1.\n例如location=[east|sourth|west|north]，计数器是4，循环依次输出里面字符串。\n3. 对于1行数据，调用了2次模板函数，每个的计数器都加1. 前面100行的tag组合都不一样，但是第101行开始host的计数器又恢复到1，location的计数器也恢复到1. 这样按计划产生的400行数据，只有100行的tags组合是不一样的。\n4. influxdb查询事会把相同时间戳，tags的数据进行去重。上例中，某个时间戳查询结果只有100行结果。\n5. 总共会产生250个时间点。那么100*250=25000就是最后返回的查询结果。\n\n### 2.2 解决\n  理解了里面运行机制， 那么可以只用1个tag， 那么生成与查询的结果就符合预期了。但是这样使用场景就太局限了。\n因此还是有必要修改一下代码，让生成的数据符合预期。应该是400个timeseries，那就生成400个不同的timeseries。\n怎么做呢？\n1. 加个计数器，每产生1行数据加1\n2. 计数器与series_count取模，得到当前series编号s_n\n3. 从左往右，依次根据s_n，(s_n - 1)计算出当前tag模板函数的计数.\n4. 如果有变化，则调用模板函数，其他tag使用上次生成的值，退出循环，结束此次模板替换。\n5. 如果无变化，继续根据s_n，(s_n - 1)计算右边下一个tag的计数，判断是否有变化。\n6. s_n计算当前模板函数计数的方式：  \n<img src=\"http://chart.googleapis.com/chart?cht=tx&chl=c=[s_n mod  (n_{i} * n_{i-1} * \\cdots * n_1 )] / (n_{i-1} * n_{i-2} * \\cdots * n_1 )\" style=\"border:none;\">\n\n改动点：\n+ ./stress/v2/statement/insert.go\n+ ./influxdb/stress/v2/statement/function.go\n","source":"_posts/2017-10-18-influxdb-stress.md","raw":"---\ntitle: influx_stress造数据令人困惑的问题\ndate: 2017-10-18 20:47:59\ntags:\n- influxdb\n- tsdb\n---\n\n## 1.简介\n  influx_stress是influxdb社区版里的一个命令。主要功能是可以解析一个脚本文件，然后执行里面的动作，包括造数据，写db，读db。\n从而对单机版进行读写压力测试。 目前有两个版本，其中v2性能更好一点。下面主要讨论v2版本存在的问题。\n\n## 2.造数据  \n### 2.1 问题    \n以下是官方文档的节选\n\n```\nYou can write points like this:\n\nINSERT mockCpu\ncpu,\nhost=server-[int inc(0) 100],location=[east|sourth|west|north]\nvalue=[float rand(1000) 0]\n100000 10s\n\nExplained:\n\n# INSERT keyword kicks off the statement, next to it is the name of the statement for reporting and templated query generation\nINSERT mockCpu\n# Measurement\ncpu,\n# Tags - separated by commas. Tag values can be templates, mixed template and fixed values\nhost=server-[float rand(100) 100],location=[int inc(0) 10],fixed=[fix|fid|dor|pom|another_tag_value]\n# Fields - separated by commas either templates, mixed template and fixed values\nvalue=[float inc(0) 0]\n# 'Timestamp' - Number of points to insert into this measurement and the amount of time between points\n100000 10s\n```  \n其中tags, fields支持模板，可以按照模板中的表达式生成对应的值。\n最后一行的100000， 表示制造的总数据量。\n看到文档， 想当然的以为插入的数据有100000行。实际执行select count后发现并不是这样， 上面这个例子最终只有25000行数据可以查询到。\n和预期的差太多了， 好奇怪。  \n\n翻了代码发现，在解析的过程中把每个模板表达式解析成1个模板函数。 例子有三个，两个tag和一个field。它是如何使用的呢？\n1. 根据tags的配置， 理论上应该有400个timeseries，因此会把100000分成250时间点。 每个时间点的数据时间戳相同， 包含400条数据。\n这个还是符合预期的。\n2. 生成每个时间点单个timeserie的数据，可以理解成db里的一行数据。依次调用模板函数，每个函数内部有个计数。当超过上限后恢复成1.\n例如location=[east|sourth|west|north]，计数器是4，循环依次输出里面字符串。\n3. 对于1行数据，调用了2次模板函数，每个的计数器都加1. 前面100行的tag组合都不一样，但是第101行开始host的计数器又恢复到1，location的计数器也恢复到1. 这样按计划产生的400行数据，只有100行的tags组合是不一样的。\n4. influxdb查询事会把相同时间戳，tags的数据进行去重。上例中，某个时间戳查询结果只有100行结果。\n5. 总共会产生250个时间点。那么100*250=25000就是最后返回的查询结果。\n\n### 2.2 解决\n  理解了里面运行机制， 那么可以只用1个tag， 那么生成与查询的结果就符合预期了。但是这样使用场景就太局限了。\n因此还是有必要修改一下代码，让生成的数据符合预期。应该是400个timeseries，那就生成400个不同的timeseries。\n怎么做呢？\n1. 加个计数器，每产生1行数据加1\n2. 计数器与series_count取模，得到当前series编号s_n\n3. 从左往右，依次根据s_n，(s_n - 1)计算出当前tag模板函数的计数.\n4. 如果有变化，则调用模板函数，其他tag使用上次生成的值，退出循环，结束此次模板替换。\n5. 如果无变化，继续根据s_n，(s_n - 1)计算右边下一个tag的计数，判断是否有变化。\n6. s_n计算当前模板函数计数的方式：  \n<img src=\"http://chart.googleapis.com/chart?cht=tx&chl=c=[s_n mod  (n_{i} * n_{i-1} * \\cdots * n_1 )] / (n_{i-1} * n_{i-2} * \\cdots * n_1 )\" style=\"border:none;\">\n\n改动点：\n+ ./stress/v2/statement/insert.go\n+ ./influxdb/stress/v2/statement/function.go\n","slug":"influxdb-stress","published":1,"updated":"2018-02-27T09:05:10.567Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje5lgp9d00016ifm78qrjhh3","content":"<h2 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1.简介\"></a>1.简介</h2><p>  influx_stress是influxdb社区版里的一个命令。主要功能是可以解析一个脚本文件，然后执行里面的动作，包括造数据，写db，读db。<br>从而对单机版进行读写压力测试。 目前有两个版本，其中v2性能更好一点。下面主要讨论v2版本存在的问题。</p>\n<h2 id=\"2-造数据\"><a href=\"#2-造数据\" class=\"headerlink\" title=\"2.造数据\"></a>2.造数据</h2><h3 id=\"2-1-问题\"><a href=\"#2-1-问题\" class=\"headerlink\" title=\"2.1 问题\"></a>2.1 问题</h3><p>以下是官方文档的节选</p>\n<pre><code>You can write points like this:\n\nINSERT mockCpu\ncpu,\nhost=server-[int inc(0) 100],location=[east|sourth|west|north]\nvalue=[float rand(1000) 0]\n100000 10s\n\nExplained:\n\n# INSERT keyword kicks off the statement, next to it is the name of the statement for reporting and templated query generation\nINSERT mockCpu\n# Measurement\ncpu,\n# Tags - separated by commas. Tag values can be templates, mixed template and fixed values\nhost=server-[float rand(100) 100],location=[int inc(0) 10],fixed=[fix|fid|dor|pom|another_tag_value]\n# Fields - separated by commas either templates, mixed template and fixed values\nvalue=[float inc(0) 0]\n# &apos;Timestamp&apos; - Number of points to insert into this measurement and the amount of time between points\n100000 10s\n</code></pre><p>其中tags, fields支持模板，可以按照模板中的表达式生成对应的值。<br>最后一行的100000， 表示制造的总数据量。<br>看到文档， 想当然的以为插入的数据有100000行。实际执行select count后发现并不是这样， 上面这个例子最终只有25000行数据可以查询到。<br>和预期的差太多了， 好奇怪。  </p>\n<p>翻了代码发现，在解析的过程中把每个模板表达式解析成1个模板函数。 例子有三个，两个tag和一个field。它是如何使用的呢？</p>\n<ol>\n<li>根据tags的配置， 理论上应该有400个timeseries，因此会把100000分成250时间点。 每个时间点的数据时间戳相同， 包含400条数据。<br>这个还是符合预期的。</li>\n<li>生成每个时间点单个timeserie的数据，可以理解成db里的一行数据。依次调用模板函数，每个函数内部有个计数。当超过上限后恢复成1.<br>例如location=[east|sourth|west|north]，计数器是4，循环依次输出里面字符串。</li>\n<li>对于1行数据，调用了2次模板函数，每个的计数器都加1. 前面100行的tag组合都不一样，但是第101行开始host的计数器又恢复到1，location的计数器也恢复到1. 这样按计划产生的400行数据，只有100行的tags组合是不一样的。</li>\n<li>influxdb查询事会把相同时间戳，tags的数据进行去重。上例中，某个时间戳查询结果只有100行结果。</li>\n<li>总共会产生250个时间点。那么100*250=25000就是最后返回的查询结果。</li>\n</ol>\n<h3 id=\"2-2-解决\"><a href=\"#2-2-解决\" class=\"headerlink\" title=\"2.2 解决\"></a>2.2 解决</h3><p>  理解了里面运行机制， 那么可以只用1个tag， 那么生成与查询的结果就符合预期了。但是这样使用场景就太局限了。<br>因此还是有必要修改一下代码，让生成的数据符合预期。应该是400个timeseries，那就生成400个不同的timeseries。<br>怎么做呢？</p>\n<ol>\n<li>加个计数器，每产生1行数据加1</li>\n<li>计数器与series_count取模，得到当前series编号s_n</li>\n<li>从左往右，依次根据s_n，(s_n - 1)计算出当前tag模板函数的计数.</li>\n<li>如果有变化，则调用模板函数，其他tag使用上次生成的值，退出循环，结束此次模板替换。</li>\n<li>如果无变化，继续根据s_n，(s_n - 1)计算右边下一个tag的计数，判断是否有变化。</li>\n<li>s_n计算当前模板函数计数的方式：<br><img src=\"http://chart.googleapis.com/chart?cht=tx&chl=c=[s_n mod  (n_{i} * n_{i-1} * \\cdots * n_1 )] / (n_{i-1} * n_{i-2} * \\cdots * n_1 )\" style=\"border:none;\"></li>\n</ol>\n<p>改动点：</p>\n<ul>\n<li>./stress/v2/statement/insert.go</li>\n<li>./influxdb/stress/v2/statement/function.go</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1.简介\"></a>1.简介</h2><p>  influx_stress是influxdb社区版里的一个命令。主要功能是可以解析一个脚本文件，然后执行里面的动作，包括造数据，写db，读db。<br>从而对单机版进行读写压力测试。 目前有两个版本，其中v2性能更好一点。下面主要讨论v2版本存在的问题。</p>\n<h2 id=\"2-造数据\"><a href=\"#2-造数据\" class=\"headerlink\" title=\"2.造数据\"></a>2.造数据</h2><h3 id=\"2-1-问题\"><a href=\"#2-1-问题\" class=\"headerlink\" title=\"2.1 问题\"></a>2.1 问题</h3><p>以下是官方文档的节选</p>\n<pre><code>You can write points like this:\n\nINSERT mockCpu\ncpu,\nhost=server-[int inc(0) 100],location=[east|sourth|west|north]\nvalue=[float rand(1000) 0]\n100000 10s\n\nExplained:\n\n# INSERT keyword kicks off the statement, next to it is the name of the statement for reporting and templated query generation\nINSERT mockCpu\n# Measurement\ncpu,\n# Tags - separated by commas. Tag values can be templates, mixed template and fixed values\nhost=server-[float rand(100) 100],location=[int inc(0) 10],fixed=[fix|fid|dor|pom|another_tag_value]\n# Fields - separated by commas either templates, mixed template and fixed values\nvalue=[float inc(0) 0]\n# &apos;Timestamp&apos; - Number of points to insert into this measurement and the amount of time between points\n100000 10s\n</code></pre><p>其中tags, fields支持模板，可以按照模板中的表达式生成对应的值。<br>最后一行的100000， 表示制造的总数据量。<br>看到文档， 想当然的以为插入的数据有100000行。实际执行select count后发现并不是这样， 上面这个例子最终只有25000行数据可以查询到。<br>和预期的差太多了， 好奇怪。  </p>\n<p>翻了代码发现，在解析的过程中把每个模板表达式解析成1个模板函数。 例子有三个，两个tag和一个field。它是如何使用的呢？</p>\n<ol>\n<li>根据tags的配置， 理论上应该有400个timeseries，因此会把100000分成250时间点。 每个时间点的数据时间戳相同， 包含400条数据。<br>这个还是符合预期的。</li>\n<li>生成每个时间点单个timeserie的数据，可以理解成db里的一行数据。依次调用模板函数，每个函数内部有个计数。当超过上限后恢复成1.<br>例如location=[east|sourth|west|north]，计数器是4，循环依次输出里面字符串。</li>\n<li>对于1行数据，调用了2次模板函数，每个的计数器都加1. 前面100行的tag组合都不一样，但是第101行开始host的计数器又恢复到1，location的计数器也恢复到1. 这样按计划产生的400行数据，只有100行的tags组合是不一样的。</li>\n<li>influxdb查询事会把相同时间戳，tags的数据进行去重。上例中，某个时间戳查询结果只有100行结果。</li>\n<li>总共会产生250个时间点。那么100*250=25000就是最后返回的查询结果。</li>\n</ol>\n<h3 id=\"2-2-解决\"><a href=\"#2-2-解决\" class=\"headerlink\" title=\"2.2 解决\"></a>2.2 解决</h3><p>  理解了里面运行机制， 那么可以只用1个tag， 那么生成与查询的结果就符合预期了。但是这样使用场景就太局限了。<br>因此还是有必要修改一下代码，让生成的数据符合预期。应该是400个timeseries，那就生成400个不同的timeseries。<br>怎么做呢？</p>\n<ol>\n<li>加个计数器，每产生1行数据加1</li>\n<li>计数器与series_count取模，得到当前series编号s_n</li>\n<li>从左往右，依次根据s_n，(s_n - 1)计算出当前tag模板函数的计数.</li>\n<li>如果有变化，则调用模板函数，其他tag使用上次生成的值，退出循环，结束此次模板替换。</li>\n<li>如果无变化，继续根据s_n，(s_n - 1)计算右边下一个tag的计数，判断是否有变化。</li>\n<li>s_n计算当前模板函数计数的方式：<br><img src=\"http://chart.googleapis.com/chart?cht=tx&chl=c=[s_n mod  (n_{i} * n_{i-1} * \\cdots * n_1 )] / (n_{i-1} * n_{i-2} * \\cdots * n_1 )\" style=\"border:none;\"></li>\n</ol>\n<p>改动点：</p>\n<ul>\n<li>./stress/v2/statement/insert.go</li>\n<li>./influxdb/stress/v2/statement/function.go</li>\n</ul>\n"},{"title":"influx_read","date":"2017-10-19T07:51:15.000Z","_content":"## 非聚和\n1. 先根据measurement创建AuxIterator。最小粒度单个timeseries，逐级merge而成。\ninterator的嵌入结构如下:\n{% asset_img \"mip-2017101919283058.png\" \"iterator层级\" %}\n2. 根据fields创建iterator，第1步的AuxIterator有新创建的FieldAuxIterator的引用\n3. AuxIterato执行backgroud\n4. 返回第2步创建的FieldAuxIterators\n\n## 创建基本类型Iterator\n基本类型Iterator包括FloatIterator，IntegerIterator，StringIterator,BooleanIterator\n1. 从元数据索引(内存 or TSI)中读取measurements所有seriesKeys\n2. 根据查询stmt里的Dimensions，对sereiesKeys进行分组形成tagset，然后组内seriesKeys排序，再对tagset排序。\n3. 对tagset里的seriesKeys再进行分组，然后创建goroutine处理每个分组\n\n## 读取的递进过程\n两条线并行进行：\n1. 返回结果的Iterator\n2. 获取底层数据的Iterator。\n    两类Cursor，cur (floatCursor)和aux(CursorAt, 对原生cursor的封装)。\n\n## 创建iterator的层级\nnode_s -> source_s > shard_s -> tagset_s -> serieskey_s\n> 1. 远程的iterator到node级别\n> 2. 涉及merger的有: node, source, shard, tagset. 基本上每级都会进行合并 \n> 3. source 是对多个shard进行source划分, 分别创建再merge合并\n\n## Questions\n### Q1: emitor里有个iterator，是如何同步多个iterator的时间戳的？\nA: 创建buildAuxIterators时，先创建1个AuxIterator。 然后再根据fields创建多个FieldAuxIterator\n同时把这些fieldAuxIterator注册到顶级AuxIterator, 最后返回fieldAuxIterator.   \n   对于不同shard的interator，如何同步的呢？  \n创建了一个SortedMergeIterator，里面有个小根heap。堆里的元素是子Iterator与point的组合结构item。\n初始化时，从每个子Iterator读1个point，然后构造heap。读取时，从顶部pop出item，读取里面的point用于返回，\n同时再从子Iterator里读一个point，然后再把这个item push到heap里。\n\n### Q2: 为何limit会比较慢\nA: 由于iterator的装饰特性, 先执行内部的mergerInterator, 再执行limit.  mergeInterator会根据所有的时间线创建1个堆,\n以便于排序. 如果维度很高,创建这个堆的过程也很耗时. 即使查询条件limit=1, 也需要一段时间来执行mergeInterator.\n","source":"_posts/2017-10-19-influxdb-read.md","raw":"---\ntitle: influx_read\ndate: 2017-10-19 15:51:15\ntags:\n---\n## 非聚和\n1. 先根据measurement创建AuxIterator。最小粒度单个timeseries，逐级merge而成。\ninterator的嵌入结构如下:\n{% asset_img \"mip-2017101919283058.png\" \"iterator层级\" %}\n2. 根据fields创建iterator，第1步的AuxIterator有新创建的FieldAuxIterator的引用\n3. AuxIterato执行backgroud\n4. 返回第2步创建的FieldAuxIterators\n\n## 创建基本类型Iterator\n基本类型Iterator包括FloatIterator，IntegerIterator，StringIterator,BooleanIterator\n1. 从元数据索引(内存 or TSI)中读取measurements所有seriesKeys\n2. 根据查询stmt里的Dimensions，对sereiesKeys进行分组形成tagset，然后组内seriesKeys排序，再对tagset排序。\n3. 对tagset里的seriesKeys再进行分组，然后创建goroutine处理每个分组\n\n## 读取的递进过程\n两条线并行进行：\n1. 返回结果的Iterator\n2. 获取底层数据的Iterator。\n    两类Cursor，cur (floatCursor)和aux(CursorAt, 对原生cursor的封装)。\n\n## 创建iterator的层级\nnode_s -> source_s > shard_s -> tagset_s -> serieskey_s\n> 1. 远程的iterator到node级别\n> 2. 涉及merger的有: node, source, shard, tagset. 基本上每级都会进行合并 \n> 3. source 是对多个shard进行source划分, 分别创建再merge合并\n\n## Questions\n### Q1: emitor里有个iterator，是如何同步多个iterator的时间戳的？\nA: 创建buildAuxIterators时，先创建1个AuxIterator。 然后再根据fields创建多个FieldAuxIterator\n同时把这些fieldAuxIterator注册到顶级AuxIterator, 最后返回fieldAuxIterator.   \n   对于不同shard的interator，如何同步的呢？  \n创建了一个SortedMergeIterator，里面有个小根heap。堆里的元素是子Iterator与point的组合结构item。\n初始化时，从每个子Iterator读1个point，然后构造heap。读取时，从顶部pop出item，读取里面的point用于返回，\n同时再从子Iterator里读一个point，然后再把这个item push到heap里。\n\n### Q2: 为何limit会比较慢\nA: 由于iterator的装饰特性, 先执行内部的mergerInterator, 再执行limit.  mergeInterator会根据所有的时间线创建1个堆,\n以便于排序. 如果维度很高,创建这个堆的过程也很耗时. 即使查询条件limit=1, 也需要一段时间来执行mergeInterator.\n","slug":"influxdb-read","published":1,"updated":"2018-02-27T09:05:10.568Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje5lgvqr00046ifmdxz2gunx","content":"<h2 id=\"非聚和\"><a href=\"#非聚和\" class=\"headerlink\" title=\"非聚和\"></a>非聚和</h2><ol>\n<li>先根据measurement创建AuxIterator。最小粒度单个timeseries，逐级merge而成。<br>interator的嵌入结构如下:</li>\n<li>根据fields创建iterator，第1步的AuxIterator有新创建的FieldAuxIterator的引用</li>\n<li>AuxIterato执行backgroud</li>\n<li>返回第2步创建的FieldAuxIterators</li>\n</ol>\n<h2 id=\"创建基本类型Iterator\"><a href=\"#创建基本类型Iterator\" class=\"headerlink\" title=\"创建基本类型Iterator\"></a>创建基本类型Iterator</h2><p>基本类型Iterator包括FloatIterator，IntegerIterator，StringIterator,BooleanIterator</p>\n<ol>\n<li>从元数据索引(内存 or TSI)中读取measurements所有seriesKeys</li>\n<li>根据查询stmt里的Dimensions，对sereiesKeys进行分组形成tagset，然后组内seriesKeys排序，再对tagset排序。</li>\n<li>对tagset里的seriesKeys再进行分组，然后创建goroutine处理每个分组</li>\n</ol>\n<h2 id=\"读取的递进过程\"><a href=\"#读取的递进过程\" class=\"headerlink\" title=\"读取的递进过程\"></a>读取的递进过程</h2><p>两条线并行进行：</p>\n<ol>\n<li>返回结果的Iterator</li>\n<li>获取底层数据的Iterator。<br> 两类Cursor，cur (floatCursor)和aux(CursorAt, 对原生cursor的封装)。</li>\n</ol>\n<h2 id=\"创建iterator的层级\"><a href=\"#创建iterator的层级\" class=\"headerlink\" title=\"创建iterator的层级\"></a>创建iterator的层级</h2><p>node_s -&gt; source_s &gt; shard_s -&gt; tagset_s -&gt; serieskey_s</p>\n<blockquote>\n<ol>\n<li>远程的iterator到node级别</li>\n<li>涉及merger的有: node, source, shard, tagset. 基本上每级都会进行合并 </li>\n<li>source 是对多个shard进行source划分, 分别创建再merge合并</li>\n</ol>\n</blockquote>\n<h2 id=\"Questions\"><a href=\"#Questions\" class=\"headerlink\" title=\"Questions\"></a>Questions</h2><h3 id=\"Q1-emitor里有个iterator，是如何同步多个iterator的时间戳的？\"><a href=\"#Q1-emitor里有个iterator，是如何同步多个iterator的时间戳的？\" class=\"headerlink\" title=\"Q1: emitor里有个iterator，是如何同步多个iterator的时间戳的？\"></a>Q1: emitor里有个iterator，是如何同步多个iterator的时间戳的？</h3><p>A: 创建buildAuxIterators时，先创建1个AuxIterator。 然后再根据fields创建多个FieldAuxIterator<br>同时把这些fieldAuxIterator注册到顶级AuxIterator, 最后返回fieldAuxIterator.<br>   对于不同shard的interator，如何同步的呢？<br>创建了一个SortedMergeIterator，里面有个小根heap。堆里的元素是子Iterator与point的组合结构item。<br>初始化时，从每个子Iterator读1个point，然后构造heap。读取时，从顶部pop出item，读取里面的point用于返回，<br>同时再从子Iterator里读一个point，然后再把这个item push到heap里。</p>\n<h3 id=\"Q2-为何limit会比较慢\"><a href=\"#Q2-为何limit会比较慢\" class=\"headerlink\" title=\"Q2: 为何limit会比较慢\"></a>Q2: 为何limit会比较慢</h3><p>A: 由于iterator的装饰特性, 先执行内部的mergerInterator, 再执行limit.  mergeInterator会根据所有的时间线创建1个堆,<br>以便于排序. 如果维度很高,创建这个堆的过程也很耗时. 即使查询条件limit=1, 也需要一段时间来执行mergeInterator.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"非聚和\"><a href=\"#非聚和\" class=\"headerlink\" title=\"非聚和\"></a>非聚和</h2><ol>\n<li>先根据measurement创建AuxIterator。最小粒度单个timeseries，逐级merge而成。<br>interator的嵌入结构如下:</li>\n<li>根据fields创建iterator，第1步的AuxIterator有新创建的FieldAuxIterator的引用</li>\n<li>AuxIterato执行backgroud</li>\n<li>返回第2步创建的FieldAuxIterators</li>\n</ol>\n<h2 id=\"创建基本类型Iterator\"><a href=\"#创建基本类型Iterator\" class=\"headerlink\" title=\"创建基本类型Iterator\"></a>创建基本类型Iterator</h2><p>基本类型Iterator包括FloatIterator，IntegerIterator，StringIterator,BooleanIterator</p>\n<ol>\n<li>从元数据索引(内存 or TSI)中读取measurements所有seriesKeys</li>\n<li>根据查询stmt里的Dimensions，对sereiesKeys进行分组形成tagset，然后组内seriesKeys排序，再对tagset排序。</li>\n<li>对tagset里的seriesKeys再进行分组，然后创建goroutine处理每个分组</li>\n</ol>\n<h2 id=\"读取的递进过程\"><a href=\"#读取的递进过程\" class=\"headerlink\" title=\"读取的递进过程\"></a>读取的递进过程</h2><p>两条线并行进行：</p>\n<ol>\n<li>返回结果的Iterator</li>\n<li>获取底层数据的Iterator。<br> 两类Cursor，cur (floatCursor)和aux(CursorAt, 对原生cursor的封装)。</li>\n</ol>\n<h2 id=\"创建iterator的层级\"><a href=\"#创建iterator的层级\" class=\"headerlink\" title=\"创建iterator的层级\"></a>创建iterator的层级</h2><p>node_s -&gt; source_s &gt; shard_s -&gt; tagset_s -&gt; serieskey_s</p>\n<blockquote>\n<ol>\n<li>远程的iterator到node级别</li>\n<li>涉及merger的有: node, source, shard, tagset. 基本上每级都会进行合并 </li>\n<li>source 是对多个shard进行source划分, 分别创建再merge合并</li>\n</ol>\n</blockquote>\n<h2 id=\"Questions\"><a href=\"#Questions\" class=\"headerlink\" title=\"Questions\"></a>Questions</h2><h3 id=\"Q1-emitor里有个iterator，是如何同步多个iterator的时间戳的？\"><a href=\"#Q1-emitor里有个iterator，是如何同步多个iterator的时间戳的？\" class=\"headerlink\" title=\"Q1: emitor里有个iterator，是如何同步多个iterator的时间戳的？\"></a>Q1: emitor里有个iterator，是如何同步多个iterator的时间戳的？</h3><p>A: 创建buildAuxIterators时，先创建1个AuxIterator。 然后再根据fields创建多个FieldAuxIterator<br>同时把这些fieldAuxIterator注册到顶级AuxIterator, 最后返回fieldAuxIterator.<br>   对于不同shard的interator，如何同步的呢？<br>创建了一个SortedMergeIterator，里面有个小根heap。堆里的元素是子Iterator与point的组合结构item。<br>初始化时，从每个子Iterator读1个point，然后构造heap。读取时，从顶部pop出item，读取里面的point用于返回，<br>同时再从子Iterator里读一个point，然后再把这个item push到heap里。</p>\n<h3 id=\"Q2-为何limit会比较慢\"><a href=\"#Q2-为何limit会比较慢\" class=\"headerlink\" title=\"Q2: 为何limit会比较慢\"></a>Q2: 为何limit会比较慢</h3><p>A: 由于iterator的装饰特性, 先执行内部的mergerInterator, 再执行limit.  mergeInterator会根据所有的时间线创建1个堆,<br>以便于排序. 如果维度很高,创建这个堆的过程也很耗时. 即使查询条件limit=1, 也需要一段时间来执行mergeInterator.</p>\n"},{"title":"influx_write","date":"2017-10-19T06:02:11.000Z","_content":"\n## 1. 架构\n{% asset_img \"mip-20171019150351540.png\" \"架构\" %}\n\n* service是对外暴露各种读写数据的服务.\n* coordinator&influxql 读写数据的抽象接口\n* store是内部具体的存储服务执行者.\n\n## 2. 存储格式\ntsm文件包含4个部分: header, blocks, index和footer.\n\n### 2.1 header\n```\n┌────────┬────────────────────────────────────┬─────────────┬──────────────┐\n│ Header │               Blocks               │    Index    │    Footer    │\n│5 bytes │              N bytes               │   N bytes   │   4 bytes    │\n└────────┴────────────────────────────────────┴─────────────┴──────────────┘\n```\n 头部前4个字节是0x16D116D1标识是tsm文件, 后1个字节是版本号.\n\n```\n┌───────────────────┐\n│      Header       │\n├─────────┬─────────┤\n│  Magic  │ Version │\n│ 4 bytes │ 1 byte  │\n└─────────┴─────────┘\n```\n### 2.2 blocks\n#### 2.2.1 block结构  \n时序数据的基本单位是block，一个block是一个timeseries在一段时间内的数据集合。   \n```\n┌───────────────────────────────────────────────────────────┐\n│                          Blocks                           │\n├───────────────────┬───────────────────┬───────────────────┤\n│      Block 1      │      Block 2      │      Block N      │\n├─────────┬─────────┼─────────┬─────────┼─────────┬─────────┤\n│  CRC    │  Data   │  CRC    │  Data   │  CRC    │  Data   │\n│ 4 bytes │ N bytes │ 4 bytes │ N bytes │ 4 bytes │ N bytes │\n└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘\n```\n\nBlock是读取的最小单元.每个block包括crc和data两部分.\n+ crc用来校验block的数据完整性\n+ data是压缩后的时间戳和value. block格式有多种, 由类型和数据分布决定.\n\n\nblock格式:\n```\n {len timestamp bytes}, {ts bytes}, {value bytes}\n```\n\n#### 2.2.2 压缩\ninfluxdb其中一个最大的卖点是文件压缩率高。一方面可以节省成本，另一方面提升单机的存储能力。\n其中tsm数据文件是主要的数据存储地方。这个文件主要存储了时序数据及在当前文件中快速查找的索引。\n时序数据是最主要的数据，对其压缩方式的选择直接决定了最终数据文件的大小。\n\n##### timestamp:\n* delta相同: {type}, {first}, {delta}, {n} || RLE\n* delta不同且max_delta < (2**60-1): {type}, {first}, {packs}  || simple8\n* delta不同且delta>=(2**60-1) : {type}, {first}, {second} ... | raw\n> 选择压缩方式有点小问题, 应该用max_delta/div的值与2**60-1比较\n\n##### float:\n* 第一个不压缩\n* 与前个值XOR, head tail的0个数, 比之前大: {10},{有效位}\n与前个值XOR, head tail的0个数, 比之前小: {11},{head_5},{len_有效位_6},{有效位}\n* 如果第2个值的head,tail都比较小且后续都比第2个大, 那么会浪费不少空间\n\n\n##### integer\n*  先计算delta, 再用zigzag编码. 把负数转成包含有效1bit尽量少.\n*  delta相同: {type},{first}, {delta}, {n} || RLE\n*  simple8 or raw\n> zigzag: uint64(uint64(x<<1)^uint64((int64(x) >> 63)))\n\n##### boolean\n* 每个值占用1bit  \n* {type}, {len}, {value_bytes}\n\n##### string  \n* {type},{snappy_string}   \n\n\n### 2.3 index\nIndex 存放的是前面 Blocks 里内容的索引。索引条目的顺序是先按照 key 的字典序排序，再按照 time 排序。InfluxDB 在做查询操作时，可以根据 Index 的信息快速定位到 tsm file 中要查询的 block 的位置。\n参考这两个结构体,更容易理解\n```\ntype KeyIndex struct {\n    KeyLen      uint16  //下面一个字段 key 的长度。\n    Key         string  //seriesKey + 分隔符 + fieldName\n    Type        byte  // Block 中 Data 内的数据的类型\n    Count       uint32 //后面紧跟着的 Blocks 索引的个数\n    Blocks      []*BlockIndex\n}\n\ntype BlockIndex struct {\n    MinTime     int64  //block 中 value 的最小时间戳\n    MaxTime     int64  //block 中 value 的最大时间戳\n    Offset      int64  //block 在整个 tsm file 中的偏移量\n    Size        uint32  //block 的大小。根据 Offset + Size 字段就可以快速读取出一个 block 中的内容\n}\n\n┌────────────────────────────────────────────────────────────────────────────┐\n│                                   Index                                    │\n├─────────┬─────────┬──────┬───────┬─────────┬─────────┬────────┬────────┬───┤\n│ Key Len │   Key   │ Type │ Count │Min Time │Max Time │ Offset │  Size  │...│\n│ 2 bytes │ N bytes │1 byte│2 bytes│ 8 bytes │ 8 bytes │8 bytes │4 bytes │   │\n└─────────┴─────────┴──────┴───────┴─────────┴─────────┴────────┴────────┴───┘\n```\n## 2.4 footer\n\nfooter有8个字节, 存储index部分在当前tsm文件里偏移值.\n```\n┌─────────┐\n│ Footer  │\n├─────────┤\n│Index Ofs│\n│ 8 bytes │\n└─────────┘\n```\n\n## 3. 请求处理\n1. 写请求处理链路\n   + http服务接收请求再转给coordinator\n   + coordinator的pointwriter包含store的引用\n   + 根据写请求参数,选择合适的shard. 如没有则创建\n   + 先写入cache,再写wal文件.\n   + 同步的写请求处理完成\n```\n http.serveWrite -> co.pointwriter -> shard -> engine -> cache -> wal\n```\n2. 压缩数据到tsm\n  + 每秒检查是否需要执行compact. 超过cache_max_size和duration_max, 执行compact\n  + 创建cache的snapshot. cache这里用了一个交换机制, 交换snapshot的store和正在提供服务的cache的store.\n  + 创建cacheKeyIteator. 并发执行数据的encode\n  + 遍历iteator,写入到tsm文件.\n\n## 4. 索引合并\n### 4.1 索引日志合并\n在index发生变化(create or drop)时,会在最后一步调用CheckLogFile, 触发tsl合并成tsi文件.  \n\n\n### 4.2 索引文件合并\n在index文件打开时,会创建goroutine不断检查合并tis文件. 索引日志合并最后也会触发索引文件合并.\n","source":"_posts/2017-10-19-influxdb-write.md","raw":"---\ntitle: influx_write\ndate: 2017-10-19 14:02:11\ntags:\n---\n\n## 1. 架构\n{% asset_img \"mip-20171019150351540.png\" \"架构\" %}\n\n* service是对外暴露各种读写数据的服务.\n* coordinator&influxql 读写数据的抽象接口\n* store是内部具体的存储服务执行者.\n\n## 2. 存储格式\ntsm文件包含4个部分: header, blocks, index和footer.\n\n### 2.1 header\n```\n┌────────┬────────────────────────────────────┬─────────────┬──────────────┐\n│ Header │               Blocks               │    Index    │    Footer    │\n│5 bytes │              N bytes               │   N bytes   │   4 bytes    │\n└────────┴────────────────────────────────────┴─────────────┴──────────────┘\n```\n 头部前4个字节是0x16D116D1标识是tsm文件, 后1个字节是版本号.\n\n```\n┌───────────────────┐\n│      Header       │\n├─────────┬─────────┤\n│  Magic  │ Version │\n│ 4 bytes │ 1 byte  │\n└─────────┴─────────┘\n```\n### 2.2 blocks\n#### 2.2.1 block结构  \n时序数据的基本单位是block，一个block是一个timeseries在一段时间内的数据集合。   \n```\n┌───────────────────────────────────────────────────────────┐\n│                          Blocks                           │\n├───────────────────┬───────────────────┬───────────────────┤\n│      Block 1      │      Block 2      │      Block N      │\n├─────────┬─────────┼─────────┬─────────┼─────────┬─────────┤\n│  CRC    │  Data   │  CRC    │  Data   │  CRC    │  Data   │\n│ 4 bytes │ N bytes │ 4 bytes │ N bytes │ 4 bytes │ N bytes │\n└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘\n```\n\nBlock是读取的最小单元.每个block包括crc和data两部分.\n+ crc用来校验block的数据完整性\n+ data是压缩后的时间戳和value. block格式有多种, 由类型和数据分布决定.\n\n\nblock格式:\n```\n {len timestamp bytes}, {ts bytes}, {value bytes}\n```\n\n#### 2.2.2 压缩\ninfluxdb其中一个最大的卖点是文件压缩率高。一方面可以节省成本，另一方面提升单机的存储能力。\n其中tsm数据文件是主要的数据存储地方。这个文件主要存储了时序数据及在当前文件中快速查找的索引。\n时序数据是最主要的数据，对其压缩方式的选择直接决定了最终数据文件的大小。\n\n##### timestamp:\n* delta相同: {type}, {first}, {delta}, {n} || RLE\n* delta不同且max_delta < (2**60-1): {type}, {first}, {packs}  || simple8\n* delta不同且delta>=(2**60-1) : {type}, {first}, {second} ... | raw\n> 选择压缩方式有点小问题, 应该用max_delta/div的值与2**60-1比较\n\n##### float:\n* 第一个不压缩\n* 与前个值XOR, head tail的0个数, 比之前大: {10},{有效位}\n与前个值XOR, head tail的0个数, 比之前小: {11},{head_5},{len_有效位_6},{有效位}\n* 如果第2个值的head,tail都比较小且后续都比第2个大, 那么会浪费不少空间\n\n\n##### integer\n*  先计算delta, 再用zigzag编码. 把负数转成包含有效1bit尽量少.\n*  delta相同: {type},{first}, {delta}, {n} || RLE\n*  simple8 or raw\n> zigzag: uint64(uint64(x<<1)^uint64((int64(x) >> 63)))\n\n##### boolean\n* 每个值占用1bit  \n* {type}, {len}, {value_bytes}\n\n##### string  \n* {type},{snappy_string}   \n\n\n### 2.3 index\nIndex 存放的是前面 Blocks 里内容的索引。索引条目的顺序是先按照 key 的字典序排序，再按照 time 排序。InfluxDB 在做查询操作时，可以根据 Index 的信息快速定位到 tsm file 中要查询的 block 的位置。\n参考这两个结构体,更容易理解\n```\ntype KeyIndex struct {\n    KeyLen      uint16  //下面一个字段 key 的长度。\n    Key         string  //seriesKey + 分隔符 + fieldName\n    Type        byte  // Block 中 Data 内的数据的类型\n    Count       uint32 //后面紧跟着的 Blocks 索引的个数\n    Blocks      []*BlockIndex\n}\n\ntype BlockIndex struct {\n    MinTime     int64  //block 中 value 的最小时间戳\n    MaxTime     int64  //block 中 value 的最大时间戳\n    Offset      int64  //block 在整个 tsm file 中的偏移量\n    Size        uint32  //block 的大小。根据 Offset + Size 字段就可以快速读取出一个 block 中的内容\n}\n\n┌────────────────────────────────────────────────────────────────────────────┐\n│                                   Index                                    │\n├─────────┬─────────┬──────┬───────┬─────────┬─────────┬────────┬────────┬───┤\n│ Key Len │   Key   │ Type │ Count │Min Time │Max Time │ Offset │  Size  │...│\n│ 2 bytes │ N bytes │1 byte│2 bytes│ 8 bytes │ 8 bytes │8 bytes │4 bytes │   │\n└─────────┴─────────┴──────┴───────┴─────────┴─────────┴────────┴────────┴───┘\n```\n## 2.4 footer\n\nfooter有8个字节, 存储index部分在当前tsm文件里偏移值.\n```\n┌─────────┐\n│ Footer  │\n├─────────┤\n│Index Ofs│\n│ 8 bytes │\n└─────────┘\n```\n\n## 3. 请求处理\n1. 写请求处理链路\n   + http服务接收请求再转给coordinator\n   + coordinator的pointwriter包含store的引用\n   + 根据写请求参数,选择合适的shard. 如没有则创建\n   + 先写入cache,再写wal文件.\n   + 同步的写请求处理完成\n```\n http.serveWrite -> co.pointwriter -> shard -> engine -> cache -> wal\n```\n2. 压缩数据到tsm\n  + 每秒检查是否需要执行compact. 超过cache_max_size和duration_max, 执行compact\n  + 创建cache的snapshot. cache这里用了一个交换机制, 交换snapshot的store和正在提供服务的cache的store.\n  + 创建cacheKeyIteator. 并发执行数据的encode\n  + 遍历iteator,写入到tsm文件.\n\n## 4. 索引合并\n### 4.1 索引日志合并\n在index发生变化(create or drop)时,会在最后一步调用CheckLogFile, 触发tsl合并成tsi文件.  \n\n\n### 4.2 索引文件合并\n在index文件打开时,会创建goroutine不断检查合并tis文件. 索引日志合并最后也会触发索引文件合并.\n","slug":"influxdb-write","published":1,"updated":"2018-02-27T09:05:10.570Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje5lh30g00056ifm9bg43xme","content":"<h2 id=\"1-架构\"><a href=\"#1-架构\" class=\"headerlink\" title=\"1. 架构\"></a>1. 架构</h2>\n<ul>\n<li>service是对外暴露各种读写数据的服务.</li>\n<li>coordinator&amp;influxql 读写数据的抽象接口</li>\n<li>store是内部具体的存储服务执行者.</li>\n</ul>\n<h2 id=\"2-存储格式\"><a href=\"#2-存储格式\" class=\"headerlink\" title=\"2. 存储格式\"></a>2. 存储格式</h2><p>tsm文件包含4个部分: header, blocks, index和footer.</p>\n<h3 id=\"2-1-header\"><a href=\"#2-1-header\" class=\"headerlink\" title=\"2.1 header\"></a>2.1 header</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">┌────────┬────────────────────────────────────┬─────────────┬──────────────┐</div><div class=\"line\">│ Header │               Blocks               │    Index    │    Footer    │</div><div class=\"line\">│5 bytes │              N bytes               │   N bytes   │   4 bytes    │</div><div class=\"line\">└────────┴────────────────────────────────────┴─────────────┴──────────────┘</div></pre></td></tr></table></figure>\n<p> 头部前4个字节是0x16D116D1标识是tsm文件, 后1个字节是版本号.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">┌───────────────────┐</div><div class=\"line\">│      Header       │</div><div class=\"line\">├─────────┬─────────┤</div><div class=\"line\">│  Magic  │ Version │</div><div class=\"line\">│ 4 bytes │ 1 byte  │</div><div class=\"line\">└─────────┴─────────┘</div></pre></td></tr></table></figure>\n<h3 id=\"2-2-blocks\"><a href=\"#2-2-blocks\" class=\"headerlink\" title=\"2.2 blocks\"></a>2.2 blocks</h3><h4 id=\"2-2-1-block结构\"><a href=\"#2-2-1-block结构\" class=\"headerlink\" title=\"2.2.1 block结构\"></a>2.2.1 block结构</h4><p>时序数据的基本单位是block，一个block是一个timeseries在一段时间内的数据集合。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">┌───────────────────────────────────────────────────────────┐</div><div class=\"line\">│                          Blocks                           │</div><div class=\"line\">├───────────────────┬───────────────────┬───────────────────┤</div><div class=\"line\">│      Block 1      │      Block 2      │      Block N      │</div><div class=\"line\">├─────────┬─────────┼─────────┬─────────┼─────────┬─────────┤</div><div class=\"line\">│  CRC    │  Data   │  CRC    │  Data   │  CRC    │  Data   │</div><div class=\"line\">│ 4 bytes │ N bytes │ 4 bytes │ N bytes │ 4 bytes │ N bytes │</div><div class=\"line\">└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘</div></pre></td></tr></table></figure></p>\n<p>Block是读取的最小单元.每个block包括crc和data两部分.</p>\n<ul>\n<li>crc用来校验block的数据完整性</li>\n<li>data是压缩后的时间戳和value. block格式有多种, 由类型和数据分布决定.</li>\n</ul>\n<p>block格式:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;len timestamp bytes&#125;, &#123;ts bytes&#125;, &#123;value bytes&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"2-2-2-压缩\"><a href=\"#2-2-2-压缩\" class=\"headerlink\" title=\"2.2.2 压缩\"></a>2.2.2 压缩</h4><p>influxdb其中一个最大的卖点是文件压缩率高。一方面可以节省成本，另一方面提升单机的存储能力。<br>其中tsm数据文件是主要的数据存储地方。这个文件主要存储了时序数据及在当前文件中快速查找的索引。<br>时序数据是最主要的数据，对其压缩方式的选择直接决定了最终数据文件的大小。</p>\n<h5 id=\"timestamp\"><a href=\"#timestamp\" class=\"headerlink\" title=\"timestamp:\"></a>timestamp:</h5><ul>\n<li>delta相同: {type}, {first}, {delta}, {n} || RLE</li>\n<li>delta不同且max_delta &lt; (2**60-1): {type}, {first}, {packs}  || simple8</li>\n<li>delta不同且delta&gt;=(2**60-1) : {type}, {first}, {second} … | raw<blockquote>\n<p>选择压缩方式有点小问题, 应该用max_delta/div的值与2**60-1比较</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"float\"><a href=\"#float\" class=\"headerlink\" title=\"float:\"></a>float:</h5><ul>\n<li>第一个不压缩</li>\n<li>与前个值XOR, head tail的0个数, 比之前大: {10},{有效位}<br>与前个值XOR, head tail的0个数, 比之前小: {11},{head<em>5},{len</em>有效位_6},{有效位}</li>\n<li>如果第2个值的head,tail都比较小且后续都比第2个大, 那么会浪费不少空间</li>\n</ul>\n<h5 id=\"integer\"><a href=\"#integer\" class=\"headerlink\" title=\"integer\"></a>integer</h5><ul>\n<li>先计算delta, 再用zigzag编码. 把负数转成包含有效1bit尽量少.</li>\n<li>delta相同: {type},{first}, {delta}, {n} || RLE</li>\n<li>simple8 or raw<blockquote>\n<p>zigzag: uint64(uint64(x&lt;<1)^uint64((int64(x)>&gt; 63)))</1)^uint64((int64(x)></p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"boolean\"><a href=\"#boolean\" class=\"headerlink\" title=\"boolean\"></a>boolean</h5><ul>\n<li>每个值占用1bit  </li>\n<li>{type}, {len}, {value_bytes}</li>\n</ul>\n<h5 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h5><ul>\n<li>{type},{snappy_string}   </li>\n</ul>\n<h3 id=\"2-3-index\"><a href=\"#2-3-index\" class=\"headerlink\" title=\"2.3 index\"></a>2.3 index</h3><p>Index 存放的是前面 Blocks 里内容的索引。索引条目的顺序是先按照 key 的字典序排序，再按照 time 排序。InfluxDB 在做查询操作时，可以根据 Index 的信息快速定位到 tsm file 中要查询的 block 的位置。<br>参考这两个结构体,更容易理解<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">type KeyIndex struct &#123;</div><div class=\"line\">    KeyLen      uint16  //下面一个字段 key 的长度。</div><div class=\"line\">    Key         string  //seriesKey + 分隔符 + fieldName</div><div class=\"line\">    Type        byte  // Block 中 Data 内的数据的类型</div><div class=\"line\">    Count       uint32 //后面紧跟着的 Blocks 索引的个数</div><div class=\"line\">    Blocks      []*BlockIndex</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">type BlockIndex struct &#123;</div><div class=\"line\">    MinTime     int64  //block 中 value 的最小时间戳</div><div class=\"line\">    MaxTime     int64  //block 中 value 的最大时间戳</div><div class=\"line\">    Offset      int64  //block 在整个 tsm file 中的偏移量</div><div class=\"line\">    Size        uint32  //block 的大小。根据 Offset + Size 字段就可以快速读取出一个 block 中的内容</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">┌────────────────────────────────────────────────────────────────────────────┐</div><div class=\"line\">│                                   Index                                    │</div><div class=\"line\">├─────────┬─────────┬──────┬───────┬─────────┬─────────┬────────┬────────┬───┤</div><div class=\"line\">│ Key Len │   Key   │ Type │ Count │Min Time │Max Time │ Offset │  Size  │...│</div><div class=\"line\">│ 2 bytes │ N bytes │1 byte│2 bytes│ 8 bytes │ 8 bytes │8 bytes │4 bytes │   │</div><div class=\"line\">└─────────┴─────────┴──────┴───────┴─────────┴─────────┴────────┴────────┴───┘</div></pre></td></tr></table></figure></p>\n<h2 id=\"2-4-footer\"><a href=\"#2-4-footer\" class=\"headerlink\" title=\"2.4 footer\"></a>2.4 footer</h2><p>footer有8个字节, 存储index部分在当前tsm文件里偏移值.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">┌─────────┐</div><div class=\"line\">│ Footer  │</div><div class=\"line\">├─────────┤</div><div class=\"line\">│Index Ofs│</div><div class=\"line\">│ 8 bytes │</div><div class=\"line\">└─────────┘</div></pre></td></tr></table></figure></p>\n<h2 id=\"3-请求处理\"><a href=\"#3-请求处理\" class=\"headerlink\" title=\"3. 请求处理\"></a>3. 请求处理</h2><ol>\n<li><p>写请求处理链路</p>\n<ul>\n<li>http服务接收请求再转给coordinator</li>\n<li>coordinator的pointwriter包含store的引用</li>\n<li>根据写请求参数,选择合适的shard. 如没有则创建</li>\n<li>先写入cache,再写wal文件.</li>\n<li>同步的写请求处理完成<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http.serveWrite -&gt; co.pointwriter -&gt; shard -&gt; engine -&gt; cache -&gt; wal</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>压缩数据到tsm</p>\n<ul>\n<li>每秒检查是否需要执行compact. 超过cache_max_size和duration_max, 执行compact</li>\n<li>创建cache的snapshot. cache这里用了一个交换机制, 交换snapshot的store和正在提供服务的cache的store.</li>\n<li>创建cacheKeyIteator. 并发执行数据的encode</li>\n<li>遍历iteator,写入到tsm文件.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"4-索引合并\"><a href=\"#4-索引合并\" class=\"headerlink\" title=\"4. 索引合并\"></a>4. 索引合并</h2><h3 id=\"4-1-索引日志合并\"><a href=\"#4-1-索引日志合并\" class=\"headerlink\" title=\"4.1 索引日志合并\"></a>4.1 索引日志合并</h3><p>在index发生变化(create or drop)时,会在最后一步调用CheckLogFile, 触发tsl合并成tsi文件.  </p>\n<h3 id=\"4-2-索引文件合并\"><a href=\"#4-2-索引文件合并\" class=\"headerlink\" title=\"4.2 索引文件合并\"></a>4.2 索引文件合并</h3><p>在index文件打开时,会创建goroutine不断检查合并tis文件. 索引日志合并最后也会触发索引文件合并.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-架构\"><a href=\"#1-架构\" class=\"headerlink\" title=\"1. 架构\"></a>1. 架构</h2>\n<ul>\n<li>service是对外暴露各种读写数据的服务.</li>\n<li>coordinator&amp;influxql 读写数据的抽象接口</li>\n<li>store是内部具体的存储服务执行者.</li>\n</ul>\n<h2 id=\"2-存储格式\"><a href=\"#2-存储格式\" class=\"headerlink\" title=\"2. 存储格式\"></a>2. 存储格式</h2><p>tsm文件包含4个部分: header, blocks, index和footer.</p>\n<h3 id=\"2-1-header\"><a href=\"#2-1-header\" class=\"headerlink\" title=\"2.1 header\"></a>2.1 header</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">┌────────┬────────────────────────────────────┬─────────────┬──────────────┐</div><div class=\"line\">│ Header │               Blocks               │    Index    │    Footer    │</div><div class=\"line\">│5 bytes │              N bytes               │   N bytes   │   4 bytes    │</div><div class=\"line\">└────────┴────────────────────────────────────┴─────────────┴──────────────┘</div></pre></td></tr></table></figure>\n<p> 头部前4个字节是0x16D116D1标识是tsm文件, 后1个字节是版本号.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">┌───────────────────┐</div><div class=\"line\">│      Header       │</div><div class=\"line\">├─────────┬─────────┤</div><div class=\"line\">│  Magic  │ Version │</div><div class=\"line\">│ 4 bytes │ 1 byte  │</div><div class=\"line\">└─────────┴─────────┘</div></pre></td></tr></table></figure>\n<h3 id=\"2-2-blocks\"><a href=\"#2-2-blocks\" class=\"headerlink\" title=\"2.2 blocks\"></a>2.2 blocks</h3><h4 id=\"2-2-1-block结构\"><a href=\"#2-2-1-block结构\" class=\"headerlink\" title=\"2.2.1 block结构\"></a>2.2.1 block结构</h4><p>时序数据的基本单位是block，一个block是一个timeseries在一段时间内的数据集合。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">┌───────────────────────────────────────────────────────────┐</div><div class=\"line\">│                          Blocks                           │</div><div class=\"line\">├───────────────────┬───────────────────┬───────────────────┤</div><div class=\"line\">│      Block 1      │      Block 2      │      Block N      │</div><div class=\"line\">├─────────┬─────────┼─────────┬─────────┼─────────┬─────────┤</div><div class=\"line\">│  CRC    │  Data   │  CRC    │  Data   │  CRC    │  Data   │</div><div class=\"line\">│ 4 bytes │ N bytes │ 4 bytes │ N bytes │ 4 bytes │ N bytes │</div><div class=\"line\">└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘</div></pre></td></tr></table></figure></p>\n<p>Block是读取的最小单元.每个block包括crc和data两部分.</p>\n<ul>\n<li>crc用来校验block的数据完整性</li>\n<li>data是压缩后的时间戳和value. block格式有多种, 由类型和数据分布决定.</li>\n</ul>\n<p>block格式:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;len timestamp bytes&#125;, &#123;ts bytes&#125;, &#123;value bytes&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"2-2-2-压缩\"><a href=\"#2-2-2-压缩\" class=\"headerlink\" title=\"2.2.2 压缩\"></a>2.2.2 压缩</h4><p>influxdb其中一个最大的卖点是文件压缩率高。一方面可以节省成本，另一方面提升单机的存储能力。<br>其中tsm数据文件是主要的数据存储地方。这个文件主要存储了时序数据及在当前文件中快速查找的索引。<br>时序数据是最主要的数据，对其压缩方式的选择直接决定了最终数据文件的大小。</p>\n<h5 id=\"timestamp\"><a href=\"#timestamp\" class=\"headerlink\" title=\"timestamp:\"></a>timestamp:</h5><ul>\n<li>delta相同: {type}, {first}, {delta}, {n} || RLE</li>\n<li>delta不同且max_delta &lt; (2**60-1): {type}, {first}, {packs}  || simple8</li>\n<li>delta不同且delta&gt;=(2**60-1) : {type}, {first}, {second} … | raw<blockquote>\n<p>选择压缩方式有点小问题, 应该用max_delta/div的值与2**60-1比较</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"float\"><a href=\"#float\" class=\"headerlink\" title=\"float:\"></a>float:</h5><ul>\n<li>第一个不压缩</li>\n<li>与前个值XOR, head tail的0个数, 比之前大: {10},{有效位}<br>与前个值XOR, head tail的0个数, 比之前小: {11},{head<em>5},{len</em>有效位_6},{有效位}</li>\n<li>如果第2个值的head,tail都比较小且后续都比第2个大, 那么会浪费不少空间</li>\n</ul>\n<h5 id=\"integer\"><a href=\"#integer\" class=\"headerlink\" title=\"integer\"></a>integer</h5><ul>\n<li>先计算delta, 再用zigzag编码. 把负数转成包含有效1bit尽量少.</li>\n<li>delta相同: {type},{first}, {delta}, {n} || RLE</li>\n<li>simple8 or raw<blockquote>\n<p>zigzag: uint64(uint64(x&lt;<1)^uint64((int64(x)>&gt; 63)))</1)^uint64((int64(x)></p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"boolean\"><a href=\"#boolean\" class=\"headerlink\" title=\"boolean\"></a>boolean</h5><ul>\n<li>每个值占用1bit  </li>\n<li>{type}, {len}, {value_bytes}</li>\n</ul>\n<h5 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h5><ul>\n<li>{type},{snappy_string}   </li>\n</ul>\n<h3 id=\"2-3-index\"><a href=\"#2-3-index\" class=\"headerlink\" title=\"2.3 index\"></a>2.3 index</h3><p>Index 存放的是前面 Blocks 里内容的索引。索引条目的顺序是先按照 key 的字典序排序，再按照 time 排序。InfluxDB 在做查询操作时，可以根据 Index 的信息快速定位到 tsm file 中要查询的 block 的位置。<br>参考这两个结构体,更容易理解<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">type KeyIndex struct &#123;</div><div class=\"line\">    KeyLen      uint16  //下面一个字段 key 的长度。</div><div class=\"line\">    Key         string  //seriesKey + 分隔符 + fieldName</div><div class=\"line\">    Type        byte  // Block 中 Data 内的数据的类型</div><div class=\"line\">    Count       uint32 //后面紧跟着的 Blocks 索引的个数</div><div class=\"line\">    Blocks      []*BlockIndex</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">type BlockIndex struct &#123;</div><div class=\"line\">    MinTime     int64  //block 中 value 的最小时间戳</div><div class=\"line\">    MaxTime     int64  //block 中 value 的最大时间戳</div><div class=\"line\">    Offset      int64  //block 在整个 tsm file 中的偏移量</div><div class=\"line\">    Size        uint32  //block 的大小。根据 Offset + Size 字段就可以快速读取出一个 block 中的内容</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">┌────────────────────────────────────────────────────────────────────────────┐</div><div class=\"line\">│                                   Index                                    │</div><div class=\"line\">├─────────┬─────────┬──────┬───────┬─────────┬─────────┬────────┬────────┬───┤</div><div class=\"line\">│ Key Len │   Key   │ Type │ Count │Min Time │Max Time │ Offset │  Size  │...│</div><div class=\"line\">│ 2 bytes │ N bytes │1 byte│2 bytes│ 8 bytes │ 8 bytes │8 bytes │4 bytes │   │</div><div class=\"line\">└─────────┴─────────┴──────┴───────┴─────────┴─────────┴────────┴────────┴───┘</div></pre></td></tr></table></figure></p>\n<h2 id=\"2-4-footer\"><a href=\"#2-4-footer\" class=\"headerlink\" title=\"2.4 footer\"></a>2.4 footer</h2><p>footer有8个字节, 存储index部分在当前tsm文件里偏移值.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">┌─────────┐</div><div class=\"line\">│ Footer  │</div><div class=\"line\">├─────────┤</div><div class=\"line\">│Index Ofs│</div><div class=\"line\">│ 8 bytes │</div><div class=\"line\">└─────────┘</div></pre></td></tr></table></figure></p>\n<h2 id=\"3-请求处理\"><a href=\"#3-请求处理\" class=\"headerlink\" title=\"3. 请求处理\"></a>3. 请求处理</h2><ol>\n<li><p>写请求处理链路</p>\n<ul>\n<li>http服务接收请求再转给coordinator</li>\n<li>coordinator的pointwriter包含store的引用</li>\n<li>根据写请求参数,选择合适的shard. 如没有则创建</li>\n<li>先写入cache,再写wal文件.</li>\n<li>同步的写请求处理完成<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http.serveWrite -&gt; co.pointwriter -&gt; shard -&gt; engine -&gt; cache -&gt; wal</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>压缩数据到tsm</p>\n<ul>\n<li>每秒检查是否需要执行compact. 超过cache_max_size和duration_max, 执行compact</li>\n<li>创建cache的snapshot. cache这里用了一个交换机制, 交换snapshot的store和正在提供服务的cache的store.</li>\n<li>创建cacheKeyIteator. 并发执行数据的encode</li>\n<li>遍历iteator,写入到tsm文件.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"4-索引合并\"><a href=\"#4-索引合并\" class=\"headerlink\" title=\"4. 索引合并\"></a>4. 索引合并</h2><h3 id=\"4-1-索引日志合并\"><a href=\"#4-1-索引日志合并\" class=\"headerlink\" title=\"4.1 索引日志合并\"></a>4.1 索引日志合并</h3><p>在index发生变化(create or drop)时,会在最后一步调用CheckLogFile, 触发tsl合并成tsi文件.  </p>\n<h3 id=\"4-2-索引文件合并\"><a href=\"#4-2-索引文件合并\" class=\"headerlink\" title=\"4.2 索引文件合并\"></a>4.2 索引文件合并</h3><p>在index文件打开时,会创建goroutine不断检查合并tis文件. 索引日志合并最后也会触发索引文件合并.</p>\n"},{"title":"influx_http_service","date":"2017-12-04T03:03:14.000Z","_content":"  支持的不同handler\n## serveOptions\n直接返回204状态码\n\n## servePing\n先记录ping的次数，再返回204状态码\n\n## serveStatus\n已过期，用servePing代替\n\n## serveWrite\n+ 先解析请求，构造points对象\n+ 调用PointsWriter的WritePoints\n+ PointsWriter是个接口，默认赋值的是coordinator.PointsWriter\n+ 0.11. 先创建shardgroup，接着mapShards得到ShardMapping ，\n然后再每个shardinfo的owner创建1个goroutine调用rpc执行写操作。\n+ 0.11. 目的节点的cluster模块监听连接，接收请求，并调用本地的TSDBStore写本地的tsdb。\n+ 1.3.  也是先mapShards， 再writeToShard。少了多data_node的rpc\n","source":"_posts/2017-12-04-influxdb-http.md","raw":"---\ntitle: influx_http_service\ndate: 2017-12-04 11:03:14\ntags:\n---\n  支持的不同handler\n## serveOptions\n直接返回204状态码\n\n## servePing\n先记录ping的次数，再返回204状态码\n\n## serveStatus\n已过期，用servePing代替\n\n## serveWrite\n+ 先解析请求，构造points对象\n+ 调用PointsWriter的WritePoints\n+ PointsWriter是个接口，默认赋值的是coordinator.PointsWriter\n+ 0.11. 先创建shardgroup，接着mapShards得到ShardMapping ，\n然后再每个shardinfo的owner创建1个goroutine调用rpc执行写操作。\n+ 0.11. 目的节点的cluster模块监听连接，接收请求，并调用本地的TSDBStore写本地的tsdb。\n+ 1.3.  也是先mapShards， 再writeToShard。少了多data_node的rpc\n","slug":"influxdb-http","published":1,"updated":"2018-02-27T09:05:10.573Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje5lhi2000066ifmxhi9iyid","content":"<p>  支持的不同handler</p>\n<h2 id=\"serveOptions\"><a href=\"#serveOptions\" class=\"headerlink\" title=\"serveOptions\"></a>serveOptions</h2><p>直接返回204状态码</p>\n<h2 id=\"servePing\"><a href=\"#servePing\" class=\"headerlink\" title=\"servePing\"></a>servePing</h2><p>先记录ping的次数，再返回204状态码</p>\n<h2 id=\"serveStatus\"><a href=\"#serveStatus\" class=\"headerlink\" title=\"serveStatus\"></a>serveStatus</h2><p>已过期，用servePing代替</p>\n<h2 id=\"serveWrite\"><a href=\"#serveWrite\" class=\"headerlink\" title=\"serveWrite\"></a>serveWrite</h2><ul>\n<li>先解析请求，构造points对象</li>\n<li>调用PointsWriter的WritePoints</li>\n<li>PointsWriter是个接口，默认赋值的是coordinator.PointsWriter</li>\n<li>0.11. 先创建shardgroup，接着mapShards得到ShardMapping ，<br>然后再每个shardinfo的owner创建1个goroutine调用rpc执行写操作。</li>\n<li>0.11. 目的节点的cluster模块监听连接，接收请求，并调用本地的TSDBStore写本地的tsdb。</li>\n<li>1.3.  也是先mapShards， 再writeToShard。少了多data_node的rpc</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>  支持的不同handler</p>\n<h2 id=\"serveOptions\"><a href=\"#serveOptions\" class=\"headerlink\" title=\"serveOptions\"></a>serveOptions</h2><p>直接返回204状态码</p>\n<h2 id=\"servePing\"><a href=\"#servePing\" class=\"headerlink\" title=\"servePing\"></a>servePing</h2><p>先记录ping的次数，再返回204状态码</p>\n<h2 id=\"serveStatus\"><a href=\"#serveStatus\" class=\"headerlink\" title=\"serveStatus\"></a>serveStatus</h2><p>已过期，用servePing代替</p>\n<h2 id=\"serveWrite\"><a href=\"#serveWrite\" class=\"headerlink\" title=\"serveWrite\"></a>serveWrite</h2><ul>\n<li>先解析请求，构造points对象</li>\n<li>调用PointsWriter的WritePoints</li>\n<li>PointsWriter是个接口，默认赋值的是coordinator.PointsWriter</li>\n<li>0.11. 先创建shardgroup，接着mapShards得到ShardMapping ，<br>然后再每个shardinfo的owner创建1个goroutine调用rpc执行写操作。</li>\n<li>0.11. 目的节点的cluster模块监听连接，接收请求，并调用本地的TSDBStore写本地的tsdb。</li>\n<li>1.3.  也是先mapShards， 再writeToShard。少了多data_node的rpc</li>\n</ul>\n"},{"title":"tsdb_references","date":"2018-02-28T03:10:14.000Z","_content":"## 需求\n[Designing apps for Time Series data](http://crispanalytics.com/blog/tag/tsdb/)\n[Time-Series Database Requirements](https://www.xaprb.com/blog/2014/06/08/time-series-database-requirements)\n[Measure Anything, Measure Everything](https://codeascraft.com/2011/02/15/measure-anything-measure-everything/)\n[Thoughts on Time-series Databases](http://jmoiron.net/blog/thoughts-on-timeseries-databases)\n\n## 设计\n[Writing a Time Series Database from Scratch](https://fabxc.org/tsdb/)\n[TODO](Graphite)\n[TODO](RRDTool)\n[TODO](Promethues)\n\n## Golang\n[The Go Programming Language](http://gopl-zh.b0.upaiyun.com/)\n[The Golang Standard Library by Example](https://books.studygolang.com/The-Golang-Standard-Library-by-Example/)\n","source":"_posts/2018-02-28-tsdb-references.md","raw":"---\ntitle: tsdb_references\ndate: 2018-02-28 11:10:14\ntags:\n---\n## 需求\n[Designing apps for Time Series data](http://crispanalytics.com/blog/tag/tsdb/)\n[Time-Series Database Requirements](https://www.xaprb.com/blog/2014/06/08/time-series-database-requirements)\n[Measure Anything, Measure Everything](https://codeascraft.com/2011/02/15/measure-anything-measure-everything/)\n[Thoughts on Time-series Databases](http://jmoiron.net/blog/thoughts-on-timeseries-databases)\n\n## 设计\n[Writing a Time Series Database from Scratch](https://fabxc.org/tsdb/)\n[TODO](Graphite)\n[TODO](RRDTool)\n[TODO](Promethues)\n\n## Golang\n[The Go Programming Language](http://gopl-zh.b0.upaiyun.com/)\n[The Golang Standard Library by Example](https://books.studygolang.com/The-Golang-Standard-Library-by-Example/)\n","slug":"tsdb-references","published":1,"updated":"2018-03-14T13:15:15.177Z","_id":"cje6i6qv300076ivlrbszfwjw","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><p><a href=\"http://crispanalytics.com/blog/tag/tsdb/\" target=\"_blank\" rel=\"noopener\">Designing apps for Time Series data</a><br><a href=\"https://www.xaprb.com/blog/2014/06/08/time-series-database-requirements\" target=\"_blank\" rel=\"noopener\">Time-Series Database Requirements</a><br><a href=\"https://codeascraft.com/2011/02/15/measure-anything-measure-everything/\" target=\"_blank\" rel=\"noopener\">Measure Anything, Measure Everything</a><br><a href=\"http://jmoiron.net/blog/thoughts-on-timeseries-databases\" target=\"_blank\" rel=\"noopener\">Thoughts on Time-series Databases</a></p>\n<h2 id=\"设计\"><a href=\"#设计\" class=\"headerlink\" title=\"设计\"></a>设计</h2><p><a href=\"https://fabxc.org/tsdb/\" target=\"_blank\" rel=\"noopener\">Writing a Time Series Database from Scratch</a><br><a href=\"Graphite\">TODO</a><br><a href=\"RRDTool\">TODO</a><br><a href=\"Promethues\">TODO</a></p>\n<h2 id=\"Golang\"><a href=\"#Golang\" class=\"headerlink\" title=\"Golang\"></a>Golang</h2><p><a href=\"http://gopl-zh.b0.upaiyun.com/\" target=\"_blank\" rel=\"noopener\">The Go Programming Language</a><br><a href=\"https://books.studygolang.com/The-Golang-Standard-Library-by-Example/\" target=\"_blank\" rel=\"noopener\">The Golang Standard Library by Example</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><p><a href=\"http://crispanalytics.com/blog/tag/tsdb/\" target=\"_blank\" rel=\"noopener\">Designing apps for Time Series data</a><br><a href=\"https://www.xaprb.com/blog/2014/06/08/time-series-database-requirements\" target=\"_blank\" rel=\"noopener\">Time-Series Database Requirements</a><br><a href=\"https://codeascraft.com/2011/02/15/measure-anything-measure-everything/\" target=\"_blank\" rel=\"noopener\">Measure Anything, Measure Everything</a><br><a href=\"http://jmoiron.net/blog/thoughts-on-timeseries-databases\" target=\"_blank\" rel=\"noopener\">Thoughts on Time-series Databases</a></p>\n<h2 id=\"设计\"><a href=\"#设计\" class=\"headerlink\" title=\"设计\"></a>设计</h2><p><a href=\"https://fabxc.org/tsdb/\" target=\"_blank\" rel=\"noopener\">Writing a Time Series Database from Scratch</a><br><a href=\"Graphite\">TODO</a><br><a href=\"RRDTool\">TODO</a><br><a href=\"Promethues\">TODO</a></p>\n<h2 id=\"Golang\"><a href=\"#Golang\" class=\"headerlink\" title=\"Golang\"></a>Golang</h2><p><a href=\"http://gopl-zh.b0.upaiyun.com/\" target=\"_blank\" rel=\"noopener\">The Go Programming Language</a><br><a href=\"https://books.studygolang.com/The-Golang-Standard-Library-by-Example/\" target=\"_blank\" rel=\"noopener\">The Golang Standard Library by Example</a></p>\n"},{"title":"tips","date":"2018-02-28T08:17:03.000Z","_content":"\n## 命令行格式化json\n```\n1.\ncat some.json |python -m json.tool\n\n2.\njq some.json\n```\n\n## git clone后如何保持与原项目同步\n```\n把原来的项目添加到：\n\ngit remote add rp [主项目地址]\n然后：\n\ngit fetch rp && git merge rp/master\n```\n\n## git 修改已提交的日志\n未push到远端\n```\ngit reset --soft [commit_id] 就可以回滚到某一个commit，然后保留下修改的内容\n```\n\n## OM7\n```\n绘图\nName: Appked SN: MFWG-GHEB-HYTW-CGHT-CSXU-QCNC-SXU\n```\n","source":"_posts/2018-02-28-tips.md","raw":"---\ntitle: tips\ndate: 2018-02-28 16:17:03\ntags:\n---\n\n## 命令行格式化json\n```\n1.\ncat some.json |python -m json.tool\n\n2.\njq some.json\n```\n\n## git clone后如何保持与原项目同步\n```\n把原来的项目添加到：\n\ngit remote add rp [主项目地址]\n然后：\n\ngit fetch rp && git merge rp/master\n```\n\n## git 修改已提交的日志\n未push到远端\n```\ngit reset --soft [commit_id] 就可以回滚到某一个commit，然后保留下修改的内容\n```\n\n## OM7\n```\n绘图\nName: Appked SN: MFWG-GHEB-HYTW-CGHT-CSXU-QCNC-SXU\n```\n","slug":"tips","published":1,"updated":"2018-03-26T15:03:01.399Z","_id":"cje6t5b0w00086ivlh8vyc1fz","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"命令行格式化json\"><a href=\"#命令行格式化json\" class=\"headerlink\" title=\"命令行格式化json\"></a>命令行格式化json</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">1.</div><div class=\"line\">cat some.json |python -m json.tool</div><div class=\"line\"></div><div class=\"line\">2.</div><div class=\"line\">jq some.json</div></pre></td></tr></table></figure>\n<h2 id=\"git-clone后如何保持与原项目同步\"><a href=\"#git-clone后如何保持与原项目同步\" class=\"headerlink\" title=\"git clone后如何保持与原项目同步\"></a>git clone后如何保持与原项目同步</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">把原来的项目添加到：</div><div class=\"line\"></div><div class=\"line\">git remote add rp [主项目地址]</div><div class=\"line\">然后：</div><div class=\"line\"></div><div class=\"line\">git fetch rp &amp;&amp; git merge rp/master</div></pre></td></tr></table></figure>\n<h2 id=\"git-修改已提交的日志\"><a href=\"#git-修改已提交的日志\" class=\"headerlink\" title=\"git 修改已提交的日志\"></a>git 修改已提交的日志</h2><p>未push到远端<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git reset --soft [commit_id] 就可以回滚到某一个commit，然后保留下修改的内容</div></pre></td></tr></table></figure></p>\n<h2 id=\"OM7\"><a href=\"#OM7\" class=\"headerlink\" title=\"OM7\"></a>OM7</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">绘图</div><div class=\"line\">Name: Appked SN: MFWG-GHEB-HYTW-CGHT-CSXU-QCNC-SXU</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"命令行格式化json\"><a href=\"#命令行格式化json\" class=\"headerlink\" title=\"命令行格式化json\"></a>命令行格式化json</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">1.</div><div class=\"line\">cat some.json |python -m json.tool</div><div class=\"line\"></div><div class=\"line\">2.</div><div class=\"line\">jq some.json</div></pre></td></tr></table></figure>\n<h2 id=\"git-clone后如何保持与原项目同步\"><a href=\"#git-clone后如何保持与原项目同步\" class=\"headerlink\" title=\"git clone后如何保持与原项目同步\"></a>git clone后如何保持与原项目同步</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">把原来的项目添加到：</div><div class=\"line\"></div><div class=\"line\">git remote add rp [主项目地址]</div><div class=\"line\">然后：</div><div class=\"line\"></div><div class=\"line\">git fetch rp &amp;&amp; git merge rp/master</div></pre></td></tr></table></figure>\n<h2 id=\"git-修改已提交的日志\"><a href=\"#git-修改已提交的日志\" class=\"headerlink\" title=\"git 修改已提交的日志\"></a>git 修改已提交的日志</h2><p>未push到远端<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git reset --soft [commit_id] 就可以回滚到某一个commit，然后保留下修改的内容</div></pre></td></tr></table></figure></p>\n<h2 id=\"OM7\"><a href=\"#OM7\" class=\"headerlink\" title=\"OM7\"></a>OM7</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">绘图</div><div class=\"line\">Name: Appked SN: MFWG-GHEB-HYTW-CGHT-CSXU-QCNC-SXU</div></pre></td></tr></table></figure>\n"},{"title":"tsdb_requirements","date":"2017-11-17T02:17:28.000Z","_content":"\n   以下内容主要翻译自Baron Schwartz的《Time-Series Database Requirements》\n\n## 1. 数据类型\n  时间序列可以定义成下面这样：\n+ 一个时间序列可以被source_name(source_id)和metric_name(metric_id)唯一标识。\n+ 一个时间序列由一系列{时间戳，值}组成，并按照时间戳排序。时间戳通常是高精度的Unix时间戳,\n值通常是浮点数。\n\n> 以opentsdb为代表的常见tsdb中的数据模型，都有tags的概念。\n从逻辑上看， tags也是时间序列唯一标识的组成部分。\n把tags提取出来，并进行kv切分，有利于执行时间线间的过滤和聚合操作。\n对tags添加一定的索引，可以提高数据的查询性能。\n\n## 2. 读写操作的特点\n   时间序列数据不是通用类型， 它们有自己的特点。一个时间序列数据库必须根据这些特点进行相应的优化。\n\n## 2.1 写\n+ 写是最常见的。通常95%-99%的操作都是写，有时更高\n+ 写入的数据通常是顺序追加的。写请求通常是按时间顺序到来的。对于TSDB这是很重要的一个限制。\n+ 很少遇到写入遥远过去的数据。最坏情况下，测量到的数据也需要在几秒或者几分钟内被写入。\n+ 更新也是很少见的。\n+ 删除是批量的，从过去某个时间开始往前所有连续的数据，例如当前时间7天以前的所有数据。删除独立的值\n或者删除随机时间范围内的值，也是罕见的。高效的批量删除很重要，尽量做到零成本。\n+ 综上所述，选择不可变的存储格式可能是好事情。使用不可变得存储格式的后果是，预定义或者固定数据范式\n在长期以后会出现问题。\n\n## 2.2 读\n+ 数据比内存大得多且很少被读取，所以缓存通常不能很好地工作。TSDB系统通常容易出现是IO制约。\n+ 读取的数据通常每个时间序列都是连续的且排序的， 按时间戳升序或者降序。\n+ 并发读或者一次读多个时间序列也是常见合理的。\n\n写入得数据按顺序到达， 一般是按{timestamp, series_id}排序，而读结果通常是按{series_id, timestamp}排序。\n读请求尽管很少，但是需要很快。通常有两种方式来处理读写。首先是写优先，数据在落盘时，没有按时间序列进行优化分布。\n读的时候使用大量的算力并行顺序地扫描所有数据。第二种是在写过程多做一些事情，把数据按时间序列分别打包到一起并且\n为顺序读做优化。\n\n## 3. 性能和容量的特点\n一个时间序列数据库应该有下面的特点：\n+ 为分布式设计-集群和分片。数据自动分布，查询自动分布。必须是容错和高可用的，通过内置数据复制和自动故障转移。\n有一些在这方面做得很好的数据库可以参考，天然分布式已经不是传说了。\n+ 把查询给数据，不要把数据给查询。 这是对查询自动分配的重申。查询可能涉及许多GB甚至TB的数据，所以\n跨网络移动是不可扩展的。\n+ 每个节点都是高效的，它可以运行大量的数据，这样就不必需要上千个节点了。\n+ 支持使用最新的高性能硬件。例如PCIe 闪存，大量内存，多核CPU.\n+ 快速和一致性。没有尖峰和停滞。执行检查点不会冻结，压缩数据不会锁住。\n\n## 4. 运维需求\n+ TSDB虽然不强调ACID, 但是当出现故障时，需要能快速把数据恢复到一致的状态。时间序列数据不像财务数据\n那样对持久性要求那么高\n+ 非阻塞的备份机制是必须的。增量备份也是个好东西\n+ 集群扩容或者缩容，不需要停机或者锁住。\n+ 压缩的存储。时间序列数据量很大，需要很高压缩率\n+ 需要很好的监控和展示运行时状态。\n\n## 5. 查询语言和API\n  我曾与许多为大公司建立大型时间序列数据库的人交谈。 他们中的大多数人告诉我，\n缺乏访问和查询数据库的高级方式是他们脖子上的长期磨刀石(负债)。\n\n我喜欢influxdb查询语言那样像sql的东西。最重要的是，要避免一些sql语言里传统限制。SQL表格是固定宽度的，并通过添加行向下增长。\n一个自然的结果是，SQL语句中的每一列都是事先已知的，并且是明确命名的，并且表达式自然地在一行内工作，\n或者在一组行中聚合，但是不能在没有JOIN的情况下跨越行工作\n\n但是，在时间序列数据库中，行是由“主键”标识的系列。随着新测量的添加，行增长横向，添加新系列时表向下增长，列是时间戳。\n因此，表格是稀疏矩阵。 表达式必须在稀疏矩阵的矩形部分进行聚合，而不仅仅是行或列，语言必须在两个方向上都允许有GROUP BY功能。\n你可以说，行和列都必须可以通过键而不是字面标识符来寻址，并且理想情况下除了严格的相等和范围之外，还可以通过模式匹配来寻址。\n\n理想情况下，查询语言和数据库应该至少支持以下服务器端处理工作，可能还有更多：\n+ 表达式，如算术和字符串操作。\n+ 聚合函数\n+ 降精度，重新采样到不同的时间精度，不同的存储介质存放不同精度的数据\n+ 不同时间序列间的表达式和操作符，例如以将不同时间序列求和或相除。\n+ 组合表达式，例如求和所有标识符与模式匹配的时间系列，然后将结果除以另一组时间系列的总和。\n+ 支持order、rank、limit等操作\n\n另一种说法是，查询语言和数据库应该设计用于分析，而不仅仅是绘制带状图。许多开源时间序列数据库（如RRDTool）\n与他们的预期使用方式紧密耦合，这是一个严重的限制。\n\n应该有一个支持批量插入的高效的二进制协议。\n\n## 6. 非功能需求\n\n我想要一个能够很好地完成一件事情的数据库。 我不认为我需要以下任何一种，我认为他们是中立的，或者在某些情况下甚至是缺点：\n+ 访问控制 - 认证和授权。\n+ 能够可视化数据，绘制图形等\n+ 在同一时间戳支持多种测量。 测量的主键是系列，时间戳，并且允许具有相同时间戳的多个值没有意义。\n+ 多维性。 一系列的多维可以存储为多个系列，多个系列可以与我指定的查询语言组合在表达式中，因此“系列”的原子已经提供了多维度的用例。\n+ 使用额外的特定键值对来“标记”测量或系列。\n+ 时间序列数据关联关系数据。\n\n## 7. 其它需求\n从我的角度来看，前面的部分描述了一个很好的通用时间序列数据库。 不错的功能可能包括：\n+ 支持保留策略。\n+ 支持以多种时间精度存储数据并选择适当的时间精度以访问给定请求。\n+ 支持自动降精度\n+ 支持查询优先级或准入控制，以防止大型查询和DOS攻击影响到服务稳定性。\n\n对于我的特殊用途，我还需要支持：\n+ 集群中任一单台服务器可以存储很多时间序列，远远超过文件目录中的文件数量。\n+ 虽然一些系列是长寿的，但很多系列并非如此。 很多都很稀少，很长一段时间只有一次测量。 系列是动态的，不是预定义的; 新系列可能随时出现。 由于这个要求，我需要高效的支持来发现在任何给定的时间范围内存在哪些系列。\n+ 物理层面的多租户。 这部分是由需求决定的; 有些客户希望知道他们的数据与其他客户的数据是分开的。\n这是部分实用的，以支持诸如每个客户的单独保留策略之类的功能。\n\n## 8. 结论\n“大数据”的未来主要是时间序列数据。 为这种用例创建一个好的时间序列数据库的人可能会做得很好。\n我确定我的要求并不是最通用或最完整的，但我希望分享是有用的。\n","source":"_posts/2017-11-17-tsdb-requirements.md","raw":"---\ntitle: tsdb_requirements\ndate: 2017-11-17 10:17:28\ntags: tsdb\n---\n\n   以下内容主要翻译自Baron Schwartz的《Time-Series Database Requirements》\n\n## 1. 数据类型\n  时间序列可以定义成下面这样：\n+ 一个时间序列可以被source_name(source_id)和metric_name(metric_id)唯一标识。\n+ 一个时间序列由一系列{时间戳，值}组成，并按照时间戳排序。时间戳通常是高精度的Unix时间戳,\n值通常是浮点数。\n\n> 以opentsdb为代表的常见tsdb中的数据模型，都有tags的概念。\n从逻辑上看， tags也是时间序列唯一标识的组成部分。\n把tags提取出来，并进行kv切分，有利于执行时间线间的过滤和聚合操作。\n对tags添加一定的索引，可以提高数据的查询性能。\n\n## 2. 读写操作的特点\n   时间序列数据不是通用类型， 它们有自己的特点。一个时间序列数据库必须根据这些特点进行相应的优化。\n\n## 2.1 写\n+ 写是最常见的。通常95%-99%的操作都是写，有时更高\n+ 写入的数据通常是顺序追加的。写请求通常是按时间顺序到来的。对于TSDB这是很重要的一个限制。\n+ 很少遇到写入遥远过去的数据。最坏情况下，测量到的数据也需要在几秒或者几分钟内被写入。\n+ 更新也是很少见的。\n+ 删除是批量的，从过去某个时间开始往前所有连续的数据，例如当前时间7天以前的所有数据。删除独立的值\n或者删除随机时间范围内的值，也是罕见的。高效的批量删除很重要，尽量做到零成本。\n+ 综上所述，选择不可变的存储格式可能是好事情。使用不可变得存储格式的后果是，预定义或者固定数据范式\n在长期以后会出现问题。\n\n## 2.2 读\n+ 数据比内存大得多且很少被读取，所以缓存通常不能很好地工作。TSDB系统通常容易出现是IO制约。\n+ 读取的数据通常每个时间序列都是连续的且排序的， 按时间戳升序或者降序。\n+ 并发读或者一次读多个时间序列也是常见合理的。\n\n写入得数据按顺序到达， 一般是按{timestamp, series_id}排序，而读结果通常是按{series_id, timestamp}排序。\n读请求尽管很少，但是需要很快。通常有两种方式来处理读写。首先是写优先，数据在落盘时，没有按时间序列进行优化分布。\n读的时候使用大量的算力并行顺序地扫描所有数据。第二种是在写过程多做一些事情，把数据按时间序列分别打包到一起并且\n为顺序读做优化。\n\n## 3. 性能和容量的特点\n一个时间序列数据库应该有下面的特点：\n+ 为分布式设计-集群和分片。数据自动分布，查询自动分布。必须是容错和高可用的，通过内置数据复制和自动故障转移。\n有一些在这方面做得很好的数据库可以参考，天然分布式已经不是传说了。\n+ 把查询给数据，不要把数据给查询。 这是对查询自动分配的重申。查询可能涉及许多GB甚至TB的数据，所以\n跨网络移动是不可扩展的。\n+ 每个节点都是高效的，它可以运行大量的数据，这样就不必需要上千个节点了。\n+ 支持使用最新的高性能硬件。例如PCIe 闪存，大量内存，多核CPU.\n+ 快速和一致性。没有尖峰和停滞。执行检查点不会冻结，压缩数据不会锁住。\n\n## 4. 运维需求\n+ TSDB虽然不强调ACID, 但是当出现故障时，需要能快速把数据恢复到一致的状态。时间序列数据不像财务数据\n那样对持久性要求那么高\n+ 非阻塞的备份机制是必须的。增量备份也是个好东西\n+ 集群扩容或者缩容，不需要停机或者锁住。\n+ 压缩的存储。时间序列数据量很大，需要很高压缩率\n+ 需要很好的监控和展示运行时状态。\n\n## 5. 查询语言和API\n  我曾与许多为大公司建立大型时间序列数据库的人交谈。 他们中的大多数人告诉我，\n缺乏访问和查询数据库的高级方式是他们脖子上的长期磨刀石(负债)。\n\n我喜欢influxdb查询语言那样像sql的东西。最重要的是，要避免一些sql语言里传统限制。SQL表格是固定宽度的，并通过添加行向下增长。\n一个自然的结果是，SQL语句中的每一列都是事先已知的，并且是明确命名的，并且表达式自然地在一行内工作，\n或者在一组行中聚合，但是不能在没有JOIN的情况下跨越行工作\n\n但是，在时间序列数据库中，行是由“主键”标识的系列。随着新测量的添加，行增长横向，添加新系列时表向下增长，列是时间戳。\n因此，表格是稀疏矩阵。 表达式必须在稀疏矩阵的矩形部分进行聚合，而不仅仅是行或列，语言必须在两个方向上都允许有GROUP BY功能。\n你可以说，行和列都必须可以通过键而不是字面标识符来寻址，并且理想情况下除了严格的相等和范围之外，还可以通过模式匹配来寻址。\n\n理想情况下，查询语言和数据库应该至少支持以下服务器端处理工作，可能还有更多：\n+ 表达式，如算术和字符串操作。\n+ 聚合函数\n+ 降精度，重新采样到不同的时间精度，不同的存储介质存放不同精度的数据\n+ 不同时间序列间的表达式和操作符，例如以将不同时间序列求和或相除。\n+ 组合表达式，例如求和所有标识符与模式匹配的时间系列，然后将结果除以另一组时间系列的总和。\n+ 支持order、rank、limit等操作\n\n另一种说法是，查询语言和数据库应该设计用于分析，而不仅仅是绘制带状图。许多开源时间序列数据库（如RRDTool）\n与他们的预期使用方式紧密耦合，这是一个严重的限制。\n\n应该有一个支持批量插入的高效的二进制协议。\n\n## 6. 非功能需求\n\n我想要一个能够很好地完成一件事情的数据库。 我不认为我需要以下任何一种，我认为他们是中立的，或者在某些情况下甚至是缺点：\n+ 访问控制 - 认证和授权。\n+ 能够可视化数据，绘制图形等\n+ 在同一时间戳支持多种测量。 测量的主键是系列，时间戳，并且允许具有相同时间戳的多个值没有意义。\n+ 多维性。 一系列的多维可以存储为多个系列，多个系列可以与我指定的查询语言组合在表达式中，因此“系列”的原子已经提供了多维度的用例。\n+ 使用额外的特定键值对来“标记”测量或系列。\n+ 时间序列数据关联关系数据。\n\n## 7. 其它需求\n从我的角度来看，前面的部分描述了一个很好的通用时间序列数据库。 不错的功能可能包括：\n+ 支持保留策略。\n+ 支持以多种时间精度存储数据并选择适当的时间精度以访问给定请求。\n+ 支持自动降精度\n+ 支持查询优先级或准入控制，以防止大型查询和DOS攻击影响到服务稳定性。\n\n对于我的特殊用途，我还需要支持：\n+ 集群中任一单台服务器可以存储很多时间序列，远远超过文件目录中的文件数量。\n+ 虽然一些系列是长寿的，但很多系列并非如此。 很多都很稀少，很长一段时间只有一次测量。 系列是动态的，不是预定义的; 新系列可能随时出现。 由于这个要求，我需要高效的支持来发现在任何给定的时间范围内存在哪些系列。\n+ 物理层面的多租户。 这部分是由需求决定的; 有些客户希望知道他们的数据与其他客户的数据是分开的。\n这是部分实用的，以支持诸如每个客户的单独保留策略之类的功能。\n\n## 8. 结论\n“大数据”的未来主要是时间序列数据。 为这种用例创建一个好的时间序列数据库的人可能会做得很好。\n我确定我的要求并不是最通用或最完整的，但我希望分享是有用的。\n","slug":"tsdb-requirements","published":1,"updated":"2018-03-13T13:28:52.781Z","_id":"cjefmnwwb00096ifmj23cjg9k","comments":1,"layout":"post","photos":[],"link":"","content":"<p>   以下内容主要翻译自Baron Schwartz的《Time-Series Database Requirements》</p>\n<h2 id=\"1-数据类型\"><a href=\"#1-数据类型\" class=\"headerlink\" title=\"1. 数据类型\"></a>1. 数据类型</h2><p>  时间序列可以定义成下面这样：</p>\n<ul>\n<li>一个时间序列可以被source_name(source_id)和metric_name(metric_id)唯一标识。</li>\n<li>一个时间序列由一系列{时间戳，值}组成，并按照时间戳排序。时间戳通常是高精度的Unix时间戳,<br>值通常是浮点数。</li>\n</ul>\n<blockquote>\n<p>以opentsdb为代表的常见tsdb中的数据模型，都有tags的概念。<br>从逻辑上看， tags也是时间序列唯一标识的组成部分。<br>把tags提取出来，并进行kv切分，有利于执行时间线间的过滤和聚合操作。<br>对tags添加一定的索引，可以提高数据的查询性能。</p>\n</blockquote>\n<h2 id=\"2-读写操作的特点\"><a href=\"#2-读写操作的特点\" class=\"headerlink\" title=\"2. 读写操作的特点\"></a>2. 读写操作的特点</h2><p>   时间序列数据不是通用类型， 它们有自己的特点。一个时间序列数据库必须根据这些特点进行相应的优化。</p>\n<h2 id=\"2-1-写\"><a href=\"#2-1-写\" class=\"headerlink\" title=\"2.1 写\"></a>2.1 写</h2><ul>\n<li>写是最常见的。通常95%-99%的操作都是写，有时更高</li>\n<li>写入的数据通常是顺序追加的。写请求通常是按时间顺序到来的。对于TSDB这是很重要的一个限制。</li>\n<li>很少遇到写入遥远过去的数据。最坏情况下，测量到的数据也需要在几秒或者几分钟内被写入。</li>\n<li>更新也是很少见的。</li>\n<li>删除是批量的，从过去某个时间开始往前所有连续的数据，例如当前时间7天以前的所有数据。删除独立的值<br>或者删除随机时间范围内的值，也是罕见的。高效的批量删除很重要，尽量做到零成本。</li>\n<li>综上所述，选择不可变的存储格式可能是好事情。使用不可变得存储格式的后果是，预定义或者固定数据范式<br>在长期以后会出现问题。</li>\n</ul>\n<h2 id=\"2-2-读\"><a href=\"#2-2-读\" class=\"headerlink\" title=\"2.2 读\"></a>2.2 读</h2><ul>\n<li>数据比内存大得多且很少被读取，所以缓存通常不能很好地工作。TSDB系统通常容易出现是IO制约。</li>\n<li>读取的数据通常每个时间序列都是连续的且排序的， 按时间戳升序或者降序。</li>\n<li>并发读或者一次读多个时间序列也是常见合理的。</li>\n</ul>\n<p>写入得数据按顺序到达， 一般是按{timestamp, series_id}排序，而读结果通常是按{series_id, timestamp}排序。<br>读请求尽管很少，但是需要很快。通常有两种方式来处理读写。首先是写优先，数据在落盘时，没有按时间序列进行优化分布。<br>读的时候使用大量的算力并行顺序地扫描所有数据。第二种是在写过程多做一些事情，把数据按时间序列分别打包到一起并且<br>为顺序读做优化。</p>\n<h2 id=\"3-性能和容量的特点\"><a href=\"#3-性能和容量的特点\" class=\"headerlink\" title=\"3. 性能和容量的特点\"></a>3. 性能和容量的特点</h2><p>一个时间序列数据库应该有下面的特点：</p>\n<ul>\n<li>为分布式设计-集群和分片。数据自动分布，查询自动分布。必须是容错和高可用的，通过内置数据复制和自动故障转移。<br>有一些在这方面做得很好的数据库可以参考，天然分布式已经不是传说了。</li>\n<li>把查询给数据，不要把数据给查询。 这是对查询自动分配的重申。查询可能涉及许多GB甚至TB的数据，所以<br>跨网络移动是不可扩展的。</li>\n<li>每个节点都是高效的，它可以运行大量的数据，这样就不必需要上千个节点了。</li>\n<li>支持使用最新的高性能硬件。例如PCIe 闪存，大量内存，多核CPU.</li>\n<li>快速和一致性。没有尖峰和停滞。执行检查点不会冻结，压缩数据不会锁住。</li>\n</ul>\n<h2 id=\"4-运维需求\"><a href=\"#4-运维需求\" class=\"headerlink\" title=\"4. 运维需求\"></a>4. 运维需求</h2><ul>\n<li>TSDB虽然不强调ACID, 但是当出现故障时，需要能快速把数据恢复到一致的状态。时间序列数据不像财务数据<br>那样对持久性要求那么高</li>\n<li>非阻塞的备份机制是必须的。增量备份也是个好东西</li>\n<li>集群扩容或者缩容，不需要停机或者锁住。</li>\n<li>压缩的存储。时间序列数据量很大，需要很高压缩率</li>\n<li>需要很好的监控和展示运行时状态。</li>\n</ul>\n<h2 id=\"5-查询语言和API\"><a href=\"#5-查询语言和API\" class=\"headerlink\" title=\"5. 查询语言和API\"></a>5. 查询语言和API</h2><p>  我曾与许多为大公司建立大型时间序列数据库的人交谈。 他们中的大多数人告诉我，<br>缺乏访问和查询数据库的高级方式是他们脖子上的长期磨刀石(负债)。</p>\n<p>我喜欢influxdb查询语言那样像sql的东西。最重要的是，要避免一些sql语言里传统限制。SQL表格是固定宽度的，并通过添加行向下增长。<br>一个自然的结果是，SQL语句中的每一列都是事先已知的，并且是明确命名的，并且表达式自然地在一行内工作，<br>或者在一组行中聚合，但是不能在没有JOIN的情况下跨越行工作</p>\n<p>但是，在时间序列数据库中，行是由“主键”标识的系列。随着新测量的添加，行增长横向，添加新系列时表向下增长，列是时间戳。<br>因此，表格是稀疏矩阵。 表达式必须在稀疏矩阵的矩形部分进行聚合，而不仅仅是行或列，语言必须在两个方向上都允许有GROUP BY功能。<br>你可以说，行和列都必须可以通过键而不是字面标识符来寻址，并且理想情况下除了严格的相等和范围之外，还可以通过模式匹配来寻址。</p>\n<p>理想情况下，查询语言和数据库应该至少支持以下服务器端处理工作，可能还有更多：</p>\n<ul>\n<li>表达式，如算术和字符串操作。</li>\n<li>聚合函数</li>\n<li>降精度，重新采样到不同的时间精度，不同的存储介质存放不同精度的数据</li>\n<li>不同时间序列间的表达式和操作符，例如以将不同时间序列求和或相除。</li>\n<li>组合表达式，例如求和所有标识符与模式匹配的时间系列，然后将结果除以另一组时间系列的总和。</li>\n<li>支持order、rank、limit等操作</li>\n</ul>\n<p>另一种说法是，查询语言和数据库应该设计用于分析，而不仅仅是绘制带状图。许多开源时间序列数据库（如RRDTool）<br>与他们的预期使用方式紧密耦合，这是一个严重的限制。</p>\n<p>应该有一个支持批量插入的高效的二进制协议。</p>\n<h2 id=\"6-非功能需求\"><a href=\"#6-非功能需求\" class=\"headerlink\" title=\"6. 非功能需求\"></a>6. 非功能需求</h2><p>我想要一个能够很好地完成一件事情的数据库。 我不认为我需要以下任何一种，我认为他们是中立的，或者在某些情况下甚至是缺点：</p>\n<ul>\n<li>访问控制 - 认证和授权。</li>\n<li>能够可视化数据，绘制图形等</li>\n<li>在同一时间戳支持多种测量。 测量的主键是系列，时间戳，并且允许具有相同时间戳的多个值没有意义。</li>\n<li>多维性。 一系列的多维可以存储为多个系列，多个系列可以与我指定的查询语言组合在表达式中，因此“系列”的原子已经提供了多维度的用例。</li>\n<li>使用额外的特定键值对来“标记”测量或系列。</li>\n<li>时间序列数据关联关系数据。</li>\n</ul>\n<h2 id=\"7-其它需求\"><a href=\"#7-其它需求\" class=\"headerlink\" title=\"7. 其它需求\"></a>7. 其它需求</h2><p>从我的角度来看，前面的部分描述了一个很好的通用时间序列数据库。 不错的功能可能包括：</p>\n<ul>\n<li>支持保留策略。</li>\n<li>支持以多种时间精度存储数据并选择适当的时间精度以访问给定请求。</li>\n<li>支持自动降精度</li>\n<li>支持查询优先级或准入控制，以防止大型查询和DOS攻击影响到服务稳定性。</li>\n</ul>\n<p>对于我的特殊用途，我还需要支持：</p>\n<ul>\n<li>集群中任一单台服务器可以存储很多时间序列，远远超过文件目录中的文件数量。</li>\n<li>虽然一些系列是长寿的，但很多系列并非如此。 很多都很稀少，很长一段时间只有一次测量。 系列是动态的，不是预定义的; 新系列可能随时出现。 由于这个要求，我需要高效的支持来发现在任何给定的时间范围内存在哪些系列。</li>\n<li>物理层面的多租户。 这部分是由需求决定的; 有些客户希望知道他们的数据与其他客户的数据是分开的。<br>这是部分实用的，以支持诸如每个客户的单独保留策略之类的功能。</li>\n</ul>\n<h2 id=\"8-结论\"><a href=\"#8-结论\" class=\"headerlink\" title=\"8. 结论\"></a>8. 结论</h2><p>“大数据”的未来主要是时间序列数据。 为这种用例创建一个好的时间序列数据库的人可能会做得很好。<br>我确定我的要求并不是最通用或最完整的，但我希望分享是有用的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>   以下内容主要翻译自Baron Schwartz的《Time-Series Database Requirements》</p>\n<h2 id=\"1-数据类型\"><a href=\"#1-数据类型\" class=\"headerlink\" title=\"1. 数据类型\"></a>1. 数据类型</h2><p>  时间序列可以定义成下面这样：</p>\n<ul>\n<li>一个时间序列可以被source_name(source_id)和metric_name(metric_id)唯一标识。</li>\n<li>一个时间序列由一系列{时间戳，值}组成，并按照时间戳排序。时间戳通常是高精度的Unix时间戳,<br>值通常是浮点数。</li>\n</ul>\n<blockquote>\n<p>以opentsdb为代表的常见tsdb中的数据模型，都有tags的概念。<br>从逻辑上看， tags也是时间序列唯一标识的组成部分。<br>把tags提取出来，并进行kv切分，有利于执行时间线间的过滤和聚合操作。<br>对tags添加一定的索引，可以提高数据的查询性能。</p>\n</blockquote>\n<h2 id=\"2-读写操作的特点\"><a href=\"#2-读写操作的特点\" class=\"headerlink\" title=\"2. 读写操作的特点\"></a>2. 读写操作的特点</h2><p>   时间序列数据不是通用类型， 它们有自己的特点。一个时间序列数据库必须根据这些特点进行相应的优化。</p>\n<h2 id=\"2-1-写\"><a href=\"#2-1-写\" class=\"headerlink\" title=\"2.1 写\"></a>2.1 写</h2><ul>\n<li>写是最常见的。通常95%-99%的操作都是写，有时更高</li>\n<li>写入的数据通常是顺序追加的。写请求通常是按时间顺序到来的。对于TSDB这是很重要的一个限制。</li>\n<li>很少遇到写入遥远过去的数据。最坏情况下，测量到的数据也需要在几秒或者几分钟内被写入。</li>\n<li>更新也是很少见的。</li>\n<li>删除是批量的，从过去某个时间开始往前所有连续的数据，例如当前时间7天以前的所有数据。删除独立的值<br>或者删除随机时间范围内的值，也是罕见的。高效的批量删除很重要，尽量做到零成本。</li>\n<li>综上所述，选择不可变的存储格式可能是好事情。使用不可变得存储格式的后果是，预定义或者固定数据范式<br>在长期以后会出现问题。</li>\n</ul>\n<h2 id=\"2-2-读\"><a href=\"#2-2-读\" class=\"headerlink\" title=\"2.2 读\"></a>2.2 读</h2><ul>\n<li>数据比内存大得多且很少被读取，所以缓存通常不能很好地工作。TSDB系统通常容易出现是IO制约。</li>\n<li>读取的数据通常每个时间序列都是连续的且排序的， 按时间戳升序或者降序。</li>\n<li>并发读或者一次读多个时间序列也是常见合理的。</li>\n</ul>\n<p>写入得数据按顺序到达， 一般是按{timestamp, series_id}排序，而读结果通常是按{series_id, timestamp}排序。<br>读请求尽管很少，但是需要很快。通常有两种方式来处理读写。首先是写优先，数据在落盘时，没有按时间序列进行优化分布。<br>读的时候使用大量的算力并行顺序地扫描所有数据。第二种是在写过程多做一些事情，把数据按时间序列分别打包到一起并且<br>为顺序读做优化。</p>\n<h2 id=\"3-性能和容量的特点\"><a href=\"#3-性能和容量的特点\" class=\"headerlink\" title=\"3. 性能和容量的特点\"></a>3. 性能和容量的特点</h2><p>一个时间序列数据库应该有下面的特点：</p>\n<ul>\n<li>为分布式设计-集群和分片。数据自动分布，查询自动分布。必须是容错和高可用的，通过内置数据复制和自动故障转移。<br>有一些在这方面做得很好的数据库可以参考，天然分布式已经不是传说了。</li>\n<li>把查询给数据，不要把数据给查询。 这是对查询自动分配的重申。查询可能涉及许多GB甚至TB的数据，所以<br>跨网络移动是不可扩展的。</li>\n<li>每个节点都是高效的，它可以运行大量的数据，这样就不必需要上千个节点了。</li>\n<li>支持使用最新的高性能硬件。例如PCIe 闪存，大量内存，多核CPU.</li>\n<li>快速和一致性。没有尖峰和停滞。执行检查点不会冻结，压缩数据不会锁住。</li>\n</ul>\n<h2 id=\"4-运维需求\"><a href=\"#4-运维需求\" class=\"headerlink\" title=\"4. 运维需求\"></a>4. 运维需求</h2><ul>\n<li>TSDB虽然不强调ACID, 但是当出现故障时，需要能快速把数据恢复到一致的状态。时间序列数据不像财务数据<br>那样对持久性要求那么高</li>\n<li>非阻塞的备份机制是必须的。增量备份也是个好东西</li>\n<li>集群扩容或者缩容，不需要停机或者锁住。</li>\n<li>压缩的存储。时间序列数据量很大，需要很高压缩率</li>\n<li>需要很好的监控和展示运行时状态。</li>\n</ul>\n<h2 id=\"5-查询语言和API\"><a href=\"#5-查询语言和API\" class=\"headerlink\" title=\"5. 查询语言和API\"></a>5. 查询语言和API</h2><p>  我曾与许多为大公司建立大型时间序列数据库的人交谈。 他们中的大多数人告诉我，<br>缺乏访问和查询数据库的高级方式是他们脖子上的长期磨刀石(负债)。</p>\n<p>我喜欢influxdb查询语言那样像sql的东西。最重要的是，要避免一些sql语言里传统限制。SQL表格是固定宽度的，并通过添加行向下增长。<br>一个自然的结果是，SQL语句中的每一列都是事先已知的，并且是明确命名的，并且表达式自然地在一行内工作，<br>或者在一组行中聚合，但是不能在没有JOIN的情况下跨越行工作</p>\n<p>但是，在时间序列数据库中，行是由“主键”标识的系列。随着新测量的添加，行增长横向，添加新系列时表向下增长，列是时间戳。<br>因此，表格是稀疏矩阵。 表达式必须在稀疏矩阵的矩形部分进行聚合，而不仅仅是行或列，语言必须在两个方向上都允许有GROUP BY功能。<br>你可以说，行和列都必须可以通过键而不是字面标识符来寻址，并且理想情况下除了严格的相等和范围之外，还可以通过模式匹配来寻址。</p>\n<p>理想情况下，查询语言和数据库应该至少支持以下服务器端处理工作，可能还有更多：</p>\n<ul>\n<li>表达式，如算术和字符串操作。</li>\n<li>聚合函数</li>\n<li>降精度，重新采样到不同的时间精度，不同的存储介质存放不同精度的数据</li>\n<li>不同时间序列间的表达式和操作符，例如以将不同时间序列求和或相除。</li>\n<li>组合表达式，例如求和所有标识符与模式匹配的时间系列，然后将结果除以另一组时间系列的总和。</li>\n<li>支持order、rank、limit等操作</li>\n</ul>\n<p>另一种说法是，查询语言和数据库应该设计用于分析，而不仅仅是绘制带状图。许多开源时间序列数据库（如RRDTool）<br>与他们的预期使用方式紧密耦合，这是一个严重的限制。</p>\n<p>应该有一个支持批量插入的高效的二进制协议。</p>\n<h2 id=\"6-非功能需求\"><a href=\"#6-非功能需求\" class=\"headerlink\" title=\"6. 非功能需求\"></a>6. 非功能需求</h2><p>我想要一个能够很好地完成一件事情的数据库。 我不认为我需要以下任何一种，我认为他们是中立的，或者在某些情况下甚至是缺点：</p>\n<ul>\n<li>访问控制 - 认证和授权。</li>\n<li>能够可视化数据，绘制图形等</li>\n<li>在同一时间戳支持多种测量。 测量的主键是系列，时间戳，并且允许具有相同时间戳的多个值没有意义。</li>\n<li>多维性。 一系列的多维可以存储为多个系列，多个系列可以与我指定的查询语言组合在表达式中，因此“系列”的原子已经提供了多维度的用例。</li>\n<li>使用额外的特定键值对来“标记”测量或系列。</li>\n<li>时间序列数据关联关系数据。</li>\n</ul>\n<h2 id=\"7-其它需求\"><a href=\"#7-其它需求\" class=\"headerlink\" title=\"7. 其它需求\"></a>7. 其它需求</h2><p>从我的角度来看，前面的部分描述了一个很好的通用时间序列数据库。 不错的功能可能包括：</p>\n<ul>\n<li>支持保留策略。</li>\n<li>支持以多种时间精度存储数据并选择适当的时间精度以访问给定请求。</li>\n<li>支持自动降精度</li>\n<li>支持查询优先级或准入控制，以防止大型查询和DOS攻击影响到服务稳定性。</li>\n</ul>\n<p>对于我的特殊用途，我还需要支持：</p>\n<ul>\n<li>集群中任一单台服务器可以存储很多时间序列，远远超过文件目录中的文件数量。</li>\n<li>虽然一些系列是长寿的，但很多系列并非如此。 很多都很稀少，很长一段时间只有一次测量。 系列是动态的，不是预定义的; 新系列可能随时出现。 由于这个要求，我需要高效的支持来发现在任何给定的时间范围内存在哪些系列。</li>\n<li>物理层面的多租户。 这部分是由需求决定的; 有些客户希望知道他们的数据与其他客户的数据是分开的。<br>这是部分实用的，以支持诸如每个客户的单独保留策略之类的功能。</li>\n</ul>\n<h2 id=\"8-结论\"><a href=\"#8-结论\" class=\"headerlink\" title=\"8. 结论\"></a>8. 结论</h2><p>“大数据”的未来主要是时间序列数据。 为这种用例创建一个好的时间序列数据库的人可能会做得很好。<br>我确定我的要求并不是最通用或最完整的，但我希望分享是有用的。</p>\n"},{"title":"grpc-go","date":"2018-03-20T06:00:48.000Z","_content":"   grpc-go是一个功能相对完备的rpc框架，支持unary, client streaming, server streaming,\nbidirectional streaming四种模式。由于使用了http2作为传输层，实际上都是stream模式。\n\n## 传输-HTTP2\n+ 二进制\n+ 十种类型的基本帧\n  其中HEADERS DATA对应HTTP1.0/1.1\n+ 多路复用的流\n+ 优先级和依赖性 PRIORITY\n+ 头压缩\n+ 重置 RST_STREAM\n+ 服务器推送 [pool or websocket]\n+ 流量控制\n+ 扩展 [ALTSVC, ]\n\n\n## Wire protocol\n  主要代码google.golang.org/grpc/rpc_util.go的encode方法。返回header和data两部分，\n这两个分布封装成独立的dataFrame发送出去。\n\n在应用层上包含两种类型的帧，分布是Request和Response\n\n```\nRequest → Request-Headers *Length-Prefixed-Message EOS\nResponse → (Response-Headers *Length-Prefixed-Message Trailers) / Trailers-Only\n```\n\n例子：Request\n```\nHEADERS (flags = END_HEADERS)\n:method = POST\n:scheme = http\n:path = /google.pubsub.v2.PublisherService/CreateTopic\n:authority = pubsub.googleapis.com\ngrpc-timeout = 1S\ncontent-type = application/grpc+proto\ngrpc-encoding = gzip\nauthorization = Bearer y235.wef315yfh138vh31hv93hv8h3v\n\nDATA (flags = END_STREAM)\n<Length-Prefixed Message>\n```\n\n例子：Response\n```\nHEADERS (flags = END_HEADERS)\n:status = 200\ngrpc-encoding = gzip\ncontent-type = application/grpc+proto\n\nDATA\n<Length-Prefixed Message>\n\nHEADERS (flags = END_STREAM, END_HEADERS)\ngrpc-status = 0 # OK\ntrace-proto-bin = jher831yy13JHy3hc\n```\n\n## Reliablity\n   gRPC官方并未直接提供服务注册与发现的功能实现，但其设计文档已提供实现的思路，\n并在不同语言的gRPC代码API中已提供了命名解析和负载均衡接口供扩展。   \n\n   服务提供方启动时，首先将服务地址注册到服务注册表，同时定期报心跳到服务注册表以表明服务的存活状态，\n相当于健康检查.服务消费方要访问某个服务时，它通过内置的LB组件向服务注册表查询，同时缓存并定期刷新目标服务地址列表，\n然后以某种负载均衡策略选择一个目标服务地址，最后向目标服务发起请求\n\n优点：不需要额外的负载均衡设备，没有单点故障\n缺点：相关策略机制都在客户端，需支持多语言，开发成本高。升级客户端，需要服务调用方配合一起升级\n\n## 易用性\n    主要体现在API和文档等方面。文档在多语言支持方面比较全面，但是在内容深度方面远远不够。\n    API在使用上没有问题，但是在client端封装不够，conn，client等暴露出来还需要自己创建和维护。\n需要有个Factory可以根据参数获取到client，在Factory内部维护conn和client的实例化。\n\n## 经验与收获\n+ go语言context在大型开源项目里的使用\n+ 生态建设，与其它开源项目的合作。\n\n## References\n[http2讲解](https://ye11ow.gitbooks.io/http2-explained/content/)\n[HPACK 完全解析](https://www.jianshu.com/p/f44b930cfcac)\n[深入了解 gRPC：协议](https://zhuanlan.zhihu.com/p/27961684)\n[gRPC-rs：从 C 到 Rust](https://zhuanlan.zhihu.com/p/27995238)\n[如何设计一个通讯协议](http://mrpeak.cn/blog/tcp-rpc-protocol/)\n[体系化认识RPC](http://www.infoq.com/cn/articles/get-to-know-rpc)\n[TiDB与gRPC的那点事](http://www.infoq.com/cn/articles/tidb-and-grpc)\n[gRPC over HTTP2](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md)\n[based pollset implementation in gRPC](https://github.com/grpc/grpc/blob/master/doc/epoll-polling-engine.md)\n[gRPC服务发现&负载均衡](http://www.open-open.com/lib/view/open1489473315209.html)\n[谈谈 HTTP/2 的协议协商机制](https://imququ.com/post/protocol-negotiation-in-http2.html)\n","source":"_posts/2018-03-20-grpc-go.md","raw":"---\ntitle: grpc-go\ndate: 2018-03-20 14:00:48\ntags:\n---\n   grpc-go是一个功能相对完备的rpc框架，支持unary, client streaming, server streaming,\nbidirectional streaming四种模式。由于使用了http2作为传输层，实际上都是stream模式。\n\n## 传输-HTTP2\n+ 二进制\n+ 十种类型的基本帧\n  其中HEADERS DATA对应HTTP1.0/1.1\n+ 多路复用的流\n+ 优先级和依赖性 PRIORITY\n+ 头压缩\n+ 重置 RST_STREAM\n+ 服务器推送 [pool or websocket]\n+ 流量控制\n+ 扩展 [ALTSVC, ]\n\n\n## Wire protocol\n  主要代码google.golang.org/grpc/rpc_util.go的encode方法。返回header和data两部分，\n这两个分布封装成独立的dataFrame发送出去。\n\n在应用层上包含两种类型的帧，分布是Request和Response\n\n```\nRequest → Request-Headers *Length-Prefixed-Message EOS\nResponse → (Response-Headers *Length-Prefixed-Message Trailers) / Trailers-Only\n```\n\n例子：Request\n```\nHEADERS (flags = END_HEADERS)\n:method = POST\n:scheme = http\n:path = /google.pubsub.v2.PublisherService/CreateTopic\n:authority = pubsub.googleapis.com\ngrpc-timeout = 1S\ncontent-type = application/grpc+proto\ngrpc-encoding = gzip\nauthorization = Bearer y235.wef315yfh138vh31hv93hv8h3v\n\nDATA (flags = END_STREAM)\n<Length-Prefixed Message>\n```\n\n例子：Response\n```\nHEADERS (flags = END_HEADERS)\n:status = 200\ngrpc-encoding = gzip\ncontent-type = application/grpc+proto\n\nDATA\n<Length-Prefixed Message>\n\nHEADERS (flags = END_STREAM, END_HEADERS)\ngrpc-status = 0 # OK\ntrace-proto-bin = jher831yy13JHy3hc\n```\n\n## Reliablity\n   gRPC官方并未直接提供服务注册与发现的功能实现，但其设计文档已提供实现的思路，\n并在不同语言的gRPC代码API中已提供了命名解析和负载均衡接口供扩展。   \n\n   服务提供方启动时，首先将服务地址注册到服务注册表，同时定期报心跳到服务注册表以表明服务的存活状态，\n相当于健康检查.服务消费方要访问某个服务时，它通过内置的LB组件向服务注册表查询，同时缓存并定期刷新目标服务地址列表，\n然后以某种负载均衡策略选择一个目标服务地址，最后向目标服务发起请求\n\n优点：不需要额外的负载均衡设备，没有单点故障\n缺点：相关策略机制都在客户端，需支持多语言，开发成本高。升级客户端，需要服务调用方配合一起升级\n\n## 易用性\n    主要体现在API和文档等方面。文档在多语言支持方面比较全面，但是在内容深度方面远远不够。\n    API在使用上没有问题，但是在client端封装不够，conn，client等暴露出来还需要自己创建和维护。\n需要有个Factory可以根据参数获取到client，在Factory内部维护conn和client的实例化。\n\n## 经验与收获\n+ go语言context在大型开源项目里的使用\n+ 生态建设，与其它开源项目的合作。\n\n## References\n[http2讲解](https://ye11ow.gitbooks.io/http2-explained/content/)\n[HPACK 完全解析](https://www.jianshu.com/p/f44b930cfcac)\n[深入了解 gRPC：协议](https://zhuanlan.zhihu.com/p/27961684)\n[gRPC-rs：从 C 到 Rust](https://zhuanlan.zhihu.com/p/27995238)\n[如何设计一个通讯协议](http://mrpeak.cn/blog/tcp-rpc-protocol/)\n[体系化认识RPC](http://www.infoq.com/cn/articles/get-to-know-rpc)\n[TiDB与gRPC的那点事](http://www.infoq.com/cn/articles/tidb-and-grpc)\n[gRPC over HTTP2](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md)\n[based pollset implementation in gRPC](https://github.com/grpc/grpc/blob/master/doc/epoll-polling-engine.md)\n[gRPC服务发现&负载均衡](http://www.open-open.com/lib/view/open1489473315209.html)\n[谈谈 HTTP/2 的协议协商机制](https://imququ.com/post/protocol-negotiation-in-http2.html)\n","slug":"grpc-go","published":1,"updated":"2018-03-26T01:54:12.185Z","_id":"cjez934fg000b6ivlhv40vsn8","comments":1,"layout":"post","photos":[],"link":"","content":"<p>   grpc-go是一个功能相对完备的rpc框架，支持unary, client streaming, server streaming,<br>bidirectional streaming四种模式。由于使用了http2作为传输层，实际上都是stream模式。</p>\n<h2 id=\"传输-HTTP2\"><a href=\"#传输-HTTP2\" class=\"headerlink\" title=\"传输-HTTP2\"></a>传输-HTTP2</h2><ul>\n<li>二进制</li>\n<li>十种类型的基本帧<br>其中HEADERS DATA对应HTTP1.0/1.1</li>\n<li>多路复用的流</li>\n<li>优先级和依赖性 PRIORITY</li>\n<li>头压缩</li>\n<li>重置 RST_STREAM</li>\n<li>服务器推送 [pool or websocket]</li>\n<li>流量控制</li>\n<li>扩展 [ALTSVC, ]</li>\n</ul>\n<h2 id=\"Wire-protocol\"><a href=\"#Wire-protocol\" class=\"headerlink\" title=\"Wire protocol\"></a>Wire protocol</h2><p>  主要代码google.golang.org/grpc/rpc_util.go的encode方法。返回header和data两部分，<br>这两个分布封装成独立的dataFrame发送出去。</p>\n<p>在应用层上包含两种类型的帧，分布是Request和Response</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Request → Request-Headers *Length-Prefixed-Message EOS</div><div class=\"line\">Response → (Response-Headers *Length-Prefixed-Message Trailers) / Trailers-Only</div></pre></td></tr></table></figure>\n<p>例子：Request<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">HEADERS (flags = END_HEADERS)</div><div class=\"line\">:method = POST</div><div class=\"line\">:scheme = http</div><div class=\"line\">:path = /google.pubsub.v2.PublisherService/CreateTopic</div><div class=\"line\">:authority = pubsub.googleapis.com</div><div class=\"line\">grpc-timeout = 1S</div><div class=\"line\">content-type = application/grpc+proto</div><div class=\"line\">grpc-encoding = gzip</div><div class=\"line\">authorization = Bearer y235.wef315yfh138vh31hv93hv8h3v</div><div class=\"line\"></div><div class=\"line\">DATA (flags = END_STREAM)</div><div class=\"line\">&lt;Length-Prefixed Message&gt;</div></pre></td></tr></table></figure></p>\n<p>例子：Response<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">HEADERS (flags = END_HEADERS)</div><div class=\"line\">:status = 200</div><div class=\"line\">grpc-encoding = gzip</div><div class=\"line\">content-type = application/grpc+proto</div><div class=\"line\"></div><div class=\"line\">DATA</div><div class=\"line\">&lt;Length-Prefixed Message&gt;</div><div class=\"line\"></div><div class=\"line\">HEADERS (flags = END_STREAM, END_HEADERS)</div><div class=\"line\">grpc-status = 0 # OK</div><div class=\"line\">trace-proto-bin = jher831yy13JHy3hc</div></pre></td></tr></table></figure></p>\n<h2 id=\"Reliablity\"><a href=\"#Reliablity\" class=\"headerlink\" title=\"Reliablity\"></a>Reliablity</h2><p>   gRPC官方并未直接提供服务注册与发现的功能实现，但其设计文档已提供实现的思路，<br>并在不同语言的gRPC代码API中已提供了命名解析和负载均衡接口供扩展。   </p>\n<p>   服务提供方启动时，首先将服务地址注册到服务注册表，同时定期报心跳到服务注册表以表明服务的存活状态，<br>相当于健康检查.服务消费方要访问某个服务时，它通过内置的LB组件向服务注册表查询，同时缓存并定期刷新目标服务地址列表，<br>然后以某种负载均衡策略选择一个目标服务地址，最后向目标服务发起请求</p>\n<p>优点：不需要额外的负载均衡设备，没有单点故障<br>缺点：相关策略机制都在客户端，需支持多语言，开发成本高。升级客户端，需要服务调用方配合一起升级</p>\n<h2 id=\"易用性\"><a href=\"#易用性\" class=\"headerlink\" title=\"易用性\"></a>易用性</h2><pre><code>主要体现在API和文档等方面。文档在多语言支持方面比较全面，但是在内容深度方面远远不够。\nAPI在使用上没有问题，但是在client端封装不够，conn，client等暴露出来还需要自己创建和维护。\n</code></pre><p>需要有个Factory可以根据参数获取到client，在Factory内部维护conn和client的实例化。</p>\n<h2 id=\"经验与收获\"><a href=\"#经验与收获\" class=\"headerlink\" title=\"经验与收获\"></a>经验与收获</h2><ul>\n<li>go语言context在大型开源项目里的使用</li>\n<li>生态建设，与其它开源项目的合作。</li>\n</ul>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><p><a href=\"https://ye11ow.gitbooks.io/http2-explained/content/\" target=\"_blank\" rel=\"noopener\">http2讲解</a><br><a href=\"https://www.jianshu.com/p/f44b930cfcac\" target=\"_blank\" rel=\"noopener\">HPACK 完全解析</a><br><a href=\"https://zhuanlan.zhihu.com/p/27961684\" target=\"_blank\" rel=\"noopener\">深入了解 gRPC：协议</a><br><a href=\"https://zhuanlan.zhihu.com/p/27995238\" target=\"_blank\" rel=\"noopener\">gRPC-rs：从 C 到 Rust</a><br><a href=\"http://mrpeak.cn/blog/tcp-rpc-protocol/\" target=\"_blank\" rel=\"noopener\">如何设计一个通讯协议</a><br><a href=\"http://www.infoq.com/cn/articles/get-to-know-rpc\" target=\"_blank\" rel=\"noopener\">体系化认识RPC</a><br><a href=\"http://www.infoq.com/cn/articles/tidb-and-grpc\" target=\"_blank\" rel=\"noopener\">TiDB与gRPC的那点事</a><br><a href=\"https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md\" target=\"_blank\" rel=\"noopener\">gRPC over HTTP2</a><br><a href=\"https://github.com/grpc/grpc/blob/master/doc/epoll-polling-engine.md\" target=\"_blank\" rel=\"noopener\">based pollset implementation in gRPC</a><br><a href=\"http://www.open-open.com/lib/view/open1489473315209.html\" target=\"_blank\" rel=\"noopener\">gRPC服务发现&amp;负载均衡</a><br><a href=\"https://imququ.com/post/protocol-negotiation-in-http2.html\" target=\"_blank\" rel=\"noopener\">谈谈 HTTP/2 的协议协商机制</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>   grpc-go是一个功能相对完备的rpc框架，支持unary, client streaming, server streaming,<br>bidirectional streaming四种模式。由于使用了http2作为传输层，实际上都是stream模式。</p>\n<h2 id=\"传输-HTTP2\"><a href=\"#传输-HTTP2\" class=\"headerlink\" title=\"传输-HTTP2\"></a>传输-HTTP2</h2><ul>\n<li>二进制</li>\n<li>十种类型的基本帧<br>其中HEADERS DATA对应HTTP1.0/1.1</li>\n<li>多路复用的流</li>\n<li>优先级和依赖性 PRIORITY</li>\n<li>头压缩</li>\n<li>重置 RST_STREAM</li>\n<li>服务器推送 [pool or websocket]</li>\n<li>流量控制</li>\n<li>扩展 [ALTSVC, ]</li>\n</ul>\n<h2 id=\"Wire-protocol\"><a href=\"#Wire-protocol\" class=\"headerlink\" title=\"Wire protocol\"></a>Wire protocol</h2><p>  主要代码google.golang.org/grpc/rpc_util.go的encode方法。返回header和data两部分，<br>这两个分布封装成独立的dataFrame发送出去。</p>\n<p>在应用层上包含两种类型的帧，分布是Request和Response</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Request → Request-Headers *Length-Prefixed-Message EOS</div><div class=\"line\">Response → (Response-Headers *Length-Prefixed-Message Trailers) / Trailers-Only</div></pre></td></tr></table></figure>\n<p>例子：Request<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">HEADERS (flags = END_HEADERS)</div><div class=\"line\">:method = POST</div><div class=\"line\">:scheme = http</div><div class=\"line\">:path = /google.pubsub.v2.PublisherService/CreateTopic</div><div class=\"line\">:authority = pubsub.googleapis.com</div><div class=\"line\">grpc-timeout = 1S</div><div class=\"line\">content-type = application/grpc+proto</div><div class=\"line\">grpc-encoding = gzip</div><div class=\"line\">authorization = Bearer y235.wef315yfh138vh31hv93hv8h3v</div><div class=\"line\"></div><div class=\"line\">DATA (flags = END_STREAM)</div><div class=\"line\">&lt;Length-Prefixed Message&gt;</div></pre></td></tr></table></figure></p>\n<p>例子：Response<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">HEADERS (flags = END_HEADERS)</div><div class=\"line\">:status = 200</div><div class=\"line\">grpc-encoding = gzip</div><div class=\"line\">content-type = application/grpc+proto</div><div class=\"line\"></div><div class=\"line\">DATA</div><div class=\"line\">&lt;Length-Prefixed Message&gt;</div><div class=\"line\"></div><div class=\"line\">HEADERS (flags = END_STREAM, END_HEADERS)</div><div class=\"line\">grpc-status = 0 # OK</div><div class=\"line\">trace-proto-bin = jher831yy13JHy3hc</div></pre></td></tr></table></figure></p>\n<h2 id=\"Reliablity\"><a href=\"#Reliablity\" class=\"headerlink\" title=\"Reliablity\"></a>Reliablity</h2><p>   gRPC官方并未直接提供服务注册与发现的功能实现，但其设计文档已提供实现的思路，<br>并在不同语言的gRPC代码API中已提供了命名解析和负载均衡接口供扩展。   </p>\n<p>   服务提供方启动时，首先将服务地址注册到服务注册表，同时定期报心跳到服务注册表以表明服务的存活状态，<br>相当于健康检查.服务消费方要访问某个服务时，它通过内置的LB组件向服务注册表查询，同时缓存并定期刷新目标服务地址列表，<br>然后以某种负载均衡策略选择一个目标服务地址，最后向目标服务发起请求</p>\n<p>优点：不需要额外的负载均衡设备，没有单点故障<br>缺点：相关策略机制都在客户端，需支持多语言，开发成本高。升级客户端，需要服务调用方配合一起升级</p>\n<h2 id=\"易用性\"><a href=\"#易用性\" class=\"headerlink\" title=\"易用性\"></a>易用性</h2><pre><code>主要体现在API和文档等方面。文档在多语言支持方面比较全面，但是在内容深度方面远远不够。\nAPI在使用上没有问题，但是在client端封装不够，conn，client等暴露出来还需要自己创建和维护。\n</code></pre><p>需要有个Factory可以根据参数获取到client，在Factory内部维护conn和client的实例化。</p>\n<h2 id=\"经验与收获\"><a href=\"#经验与收获\" class=\"headerlink\" title=\"经验与收获\"></a>经验与收获</h2><ul>\n<li>go语言context在大型开源项目里的使用</li>\n<li>生态建设，与其它开源项目的合作。</li>\n</ul>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><p><a href=\"https://ye11ow.gitbooks.io/http2-explained/content/\" target=\"_blank\" rel=\"noopener\">http2讲解</a><br><a href=\"https://www.jianshu.com/p/f44b930cfcac\" target=\"_blank\" rel=\"noopener\">HPACK 完全解析</a><br><a href=\"https://zhuanlan.zhihu.com/p/27961684\" target=\"_blank\" rel=\"noopener\">深入了解 gRPC：协议</a><br><a href=\"https://zhuanlan.zhihu.com/p/27995238\" target=\"_blank\" rel=\"noopener\">gRPC-rs：从 C 到 Rust</a><br><a href=\"http://mrpeak.cn/blog/tcp-rpc-protocol/\" target=\"_blank\" rel=\"noopener\">如何设计一个通讯协议</a><br><a href=\"http://www.infoq.com/cn/articles/get-to-know-rpc\" target=\"_blank\" rel=\"noopener\">体系化认识RPC</a><br><a href=\"http://www.infoq.com/cn/articles/tidb-and-grpc\" target=\"_blank\" rel=\"noopener\">TiDB与gRPC的那点事</a><br><a href=\"https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md\" target=\"_blank\" rel=\"noopener\">gRPC over HTTP2</a><br><a href=\"https://github.com/grpc/grpc/blob/master/doc/epoll-polling-engine.md\" target=\"_blank\" rel=\"noopener\">based pollset implementation in gRPC</a><br><a href=\"http://www.open-open.com/lib/view/open1489473315209.html\" target=\"_blank\" rel=\"noopener\">gRPC服务发现&amp;负载均衡</a><br><a href=\"https://imququ.com/post/protocol-negotiation-in-http2.html\" target=\"_blank\" rel=\"noopener\">谈谈 HTTP/2 的协议协商机制</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cje5g49g40000h2vljo41dxnf","tag_id":"cje5g49ga0002h2vlfeuprd43","_id":"cje5g49gk000bh2vlh86zhru5"},{"post_id":"cje5g49g40000h2vljo41dxnf","tag_id":"cje5g49gf0006h2vltazqq0pc","_id":"cje5g49gl000dh2vli4s7i7f9"},{"post_id":"cje5lgp9d00016ifm78qrjhh3","tag_id":"cje5g49gh0009h2vlq9frg8us","_id":"cje5lgp9g00026ifmga21oclw"},{"post_id":"cje5lgp9d00016ifm78qrjhh3","tag_id":"cje5g49gl000eh2vloc8q4j7l","_id":"cje5lgp9g00036ifmgpr6sr69"},{"post_id":"cjefmnwwb00096ifmj23cjg9k","tag_id":"cje5g49gl000eh2vloc8q4j7l","_id":"cjefmnwwd000a6ifm8e8roadx"}],"Tag":[{"name":"tips","_id":"cje5g49ga0002h2vlfeuprd43"},{"name":"life","_id":"cje5g49gf0006h2vltazqq0pc"},{"name":"influxdb","_id":"cje5g49gh0009h2vlq9frg8us"},{"name":"tsdb","_id":"cje5g49gl000eh2vloc8q4j7l"}]}}