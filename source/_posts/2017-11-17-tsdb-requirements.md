---
title: tsdb_requirements
date: 2017-11-17 10:17:28
tags: tsdb
---

   以下内容主要翻译自Baron Schwartz的《Time-Series Database Requirements》

## 1. 数据类型
  时间序列可以定义成下面这样：
+ 一个时间序列可以被source_name(source_id)和metric_name(metric_id)唯一标识。
+ 一个时间序列由一系列{时间戳，值}组成，并按照时间戳排序。时间戳通常是高精度的Unix时间戳,
值通常是浮点数。

> 以opentsdb为代表的常见tsdb中的数据模型，都有tags的概念。
从逻辑上看， tags也是时间序列唯一标识的组成部分。
把tags提取出来，并进行kv切分，有利于执行时间线间的过滤和聚合操作。
对tags添加一定的索引，可以提高数据的查询性能。

## 2. 读写操作的特点
   时间序列数据不是通用类型， 它们有自己的特点。一个时间序列数据库必须根据这些特点进行相应的优化。

## 2.1 写
+ 写是最常见的。通常95%-99%的操作都是写，有时更高
+ 写入的数据通常是顺序追加的。写请求通常是按时间顺序到来的。对于TSDB这是很重要的一个限制。
+ 很少遇到写入遥远过去的数据。最坏情况下，测量到的数据也需要在几秒或者几分钟内被写入。
+ 更新也是很少见的。
+ 删除是批量的，从过去某个时间开始往前所有连续的数据，例如当前时间7天以前的所有数据。删除独立的值
或者删除随机时间范围内的值，也是罕见的。高效的批量删除很重要，尽量做到零成本。
+ 综上所述，选择不可变的存储格式可能是好事情。使用不可变的存储格式的后果是，预定义或者固定数据范式
在长期以后会出现问题。

## 2.2 读
+ 数据比内存大得多且很少被读取，所以缓存通常不能很好地工作。TSDB系统通常容易出现是IO制约。
+ 读取的数据通常每个时间序列都是连续的且排序的， 按时间戳升序或者降序。
+ 并发读或者一次读多个时间序列也是常见合理的。

写入得数据按顺序到达， 一般是按{timestamp, series_id}排序，而读结果通常是按{series_id, timestamp}排序。
读请求尽管很少，但是需要很快。通常有两种方式来处理读写。首先是写优先，数据在落盘时，没有按时间序列进行优化分布。
读的时候使用大量的算力并行顺序地扫描所有数据。第二种是在写过程多做一些事情，把数据按时间序列分别打包到一起并且
为顺序读做优化。

## 3. 性能和容量的特点
一个时间序列数据库应该有下面的特点：
+ 为分布式设计-集群和分片。数据自动分布，查询自动分布。必须是容错和高可用的，通过内置数据复制和自动故障转移。
有一些在这方面做得很好的数据库可以参考，天然分布式已经不是传说了。
+ 把查询给数据，不要把数据给查询。 这是对查询自动分配的重申。查询可能涉及许多GB甚至TB的数据，所以
跨网络移动是不可扩展的。
+ 每个节点都是高效的，它可以运行大量的数据，这样就不必需要上千个节点了。
+ 支持使用最新的高性能硬件。例如PCIe 闪存，大量内存，多核CPU.
+ 快速和一致性。没有尖峰和停滞。执行检查点不会冻结，压缩数据不会锁住。

## 4. 运维需求
+ TSDB虽然不强调ACID, 但是当出现故障时，需要能快速把数据恢复到一致的状态。时间序列数据不像财务数据
那样对持久性要求那么高
+ 非阻塞的备份机制是必须的。增量备份也是个好东西
+ 集群扩容或者缩容，不需要停机或者锁住。
+ 压缩的存储。时间序列数据量很大，需要很高压缩率
+ 需要很好的监控和展示运行时状态。

## 5. 查询语言和API
  我曾与许多为大公司建立大型时间序列数据库的人交谈。 他们中的大多数人告诉我，
缺乏访问和查询数据库的高级方式是他们脖子上的长期磨刀石(负债)。

我喜欢influxdb查询语言那样像sql的东西。最重要的是，要避免一些sql语言里传统限制。
SQL表格是固定宽度的，并通过添加行向下增长。
一个自然的结果是，SQL语句中的每一列都是事先已知的，并且是明确命名的，并且表达式自然地在一行内工作，
或者在一组行中聚合，但是不能在没有JOIN的情况下跨越行工作

但是，在时间序列数据库中，行是由“主键”标识的系列。随着新测量的添加，行增长横向，添加新系列时表向下增长，列是时间戳。
因此，表格是稀疏矩阵。 表达式必须在稀疏矩阵的矩形部分进行聚合，而不仅仅是行或列，语言必须在两个方向上都允许有GROUP BY功能。
你可以说，行和列都必须可以通过键而不是字面标识符来寻址，并且理想情况下除了严格的相等和范围之外，还可以通过模式匹配来寻址。

理想情况下，查询语言和数据库应该至少支持以下服务器端处理工作，可能还有更多：
+ 表达式，如算术和字符串操作
+ 聚合函数
+ 降精度，重新采样到不同的时间精度，不同的存储介质存放不同精度的数据
+ 不同时间序列间的表达式和操作符，例如以将不同时间序列求和或相除
+ 组合表达式，例如求和所有标识符与模式匹配的时间系列，然后将结果除以另一组时间系列的总和
+ 支持order、rank、limit等操作

另一种说法是，查询语言和数据库应该设计用于分析，而不仅仅是绘制带状图。许多开源时间序列数据库（如RRDTool）
与他们的预期使用方式紧密耦合，这是一个严重的限制。

应该有一个支持批量插入的高效的二进制协议。

## 6. 非功能需求

我想要一个能够很好地完成一件事情的数据库。 我不认为我需要以下任何一种，我认为他们是中立的，或者在某些情况下甚至是缺点：
+ 访问控制 - 认证和授权。
+ 能够可视化数据，绘制图形等
+ 在同一时间戳支持多种测量。 测量的主键是系列，时间戳，并且允许具有相同时间戳的多个值没有意义。
+ 多维性。 一系列的多维可以存储为多个系列，多个系列可以与我指定的查询语言组合在表达式中，因此“系列”的原子已经提供了多维度的用例。
+ 使用额外的特定键值对来“标记”测量或系列。
+ 时间序列数据关联关系数据。

## 7. 其它需求
从我的角度来看，前面的部分描述了一个很好的通用时间序列数据库。 不错的功能可能包括：
+ 支持保留策略。
+ 支持以多种时间精度存储数据并选择适当的时间精度以访问给定请求。
+ 支持自动降精度
+ 支持查询优先级或准入控制，以防止大型查询和DOS攻击影响到服务稳定性。

对于我的特殊用途，我还需要支持：
+ 集群中任一单台服务器可以存储很多时间序列, 远远超过文件目录中的文件数量.
+ 虽然一些系列是长寿的，但很多系列并非如此. 很多都很稀少，很长一段时间只有一次测量.
 系列是动态的，不是预定义的; 新时间序列可能随时出现。
 由于这个要求，我需要高效的支持来发现在任何给定的时间范围内存在哪些时间序列。
+ 物理层面的多租户。 这部分是由需求决定的; 有些客户希望知道他们的数据与其他客户的数据是分开的。
这是部分实用的，以支持诸如每个客户的单独保留策略之类的功能。

## 8. 结论
“大数据”的未来主要是时间序列数据。 为这种用例创建一个好的时间序列数据库的人可能会做得很好。
我确定我的要求并不是最通用或最完整的，但我希望分享是有用的。
